var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Traits","page":"API","title":"Traits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterface.can_avx\nArrayInterface.can_change_size\nArrayInterface.can_setindex\nArrayInterface.contiguous_axis\nArrayInterface.contiguous_axis_indicator\nArrayInterface.contiguous_batch_size\nArrayInterface.defines_strides\nArrayInterface.device\nArrayInterface.dimnames\nArrayInterface.fast_matrix_colors\nArrayInterface.fast_scalar_indexing\nArrayInterface.has_dimnames\nArrayInterface.has_parent\nArrayInterface.has_sparsestruct\nArrayInterface.is_column_major\nArrayInterface.is_lazy_conjugate\nArrayInterface.ismutable\nArrayInterface.issingular\nArrayInterface.isstructured\nArrayInterface.is_splat_index\nArrayInterface.known_dimnames\nArrayInterface.known_first\nArrayInterface.known_last\nArrayInterface.known_length\nArrayInterface.known_offset1\nArrayInterface.known_offsets\nArrayInterface.known_size\nArrayInterface.known_step\nArrayInterface.known_strides\nArrayInterface.ndims_index","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterface.allowed_getindex\nArrayInterface.allowed_setindex!\nArrayInterface.aos_to_soa\nArrayInterface.axes\nArrayInterface.axes_types\nArrayInterface.broadcast_axis\nArrayInterface.buffer\nArrayInterface.deleteat\nArrayInterface.dense_dims\nArrayInterface.findstructralnz\nArrayInterface.from_parent_dims\nArrayInterface.getindex\nArrayInterface.indices\nArrayInterface.insert\nArrayInterface.lazy_axes\nArrayInterface.lu_instance\nArrayInterface.matrix_colors\nArrayInterface.offset1\nArrayInterface.offsets\nArrayInterface.parent_type\nArrayInterface.restructure\nArrayInterface.safevec\nArrayInterface.setindex!\nArrayInterface.size\nArrayInterface.strides\nArrayInterface.to_axes\nArrayInterface.to_axis\nArrayInterface.to_dims\nArrayInterface.to_index\nArrayInterface.to_indices\nArrayInterface.to_parent_dims\nArrayInterface.unsafe_reconstruct\nArrayInterface.zeromatrix","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterface.ArrayIndex\nArrayInterface.BroadcastAxis\nArrayInterface.LazyAxis\nArrayInterface.OptionallyStaticStepRange\nArrayInterface.OptionallyStaticUnitRange\nArrayInteraface.SOneTo\nArrayInteraface.SUnitRange\nArrayInterface.StrideIndex","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArrayInterface","category":"page"},{"location":"#ArrayInterface","page":"Home","title":"ArrayInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Designs for new Base array interface primitives, used widely through scientific machine learning (SciML) and other organizations","category":"page"},{"location":"#Inheriting-Array-Traits","page":"Home","title":"Inheriting Array Traits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creating an array type with unique behavior in Julia is often accomplished by creating a lazy wrapper around previously defined array types (e.g. composition by inheritance). This allows the new array type to inherit functionality by redirecting methods to the parent array (e.g., Base.size(x::Wrapper) = size(parent(x))). Generic design limits the need to define an excessive number of methods like this. However, methods used to describe a type's traits often need to be explicitly defined for each trait method. ArrayInterface assists with this by providing information about the parent type using ArrayInterface.parent_type. By default ArrayInterface.parent_type(::Type{T}) returns T (analogous to Base.parent(x) = x). If any type other than T is returned we assume T wraps a parent structure, so methods know to unwrap instances of T. It is also assumed that if T has a parent type Base.parent is defined.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For those authoring new trait methods, this may change the default definition from has_trait(::Type{T}) where {T} = false, to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function has_trait(::Type{T}) where {T}\n    if parent_type(T) <:T\n        return false\n    else\n        return has_trait(parent_type(T))\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most traits in ArrayInterface are a variant on this pattern. If the trait in question may be altered by a wrapper array, this pattern should be altered or may be inappropriate.","category":"page"},{"location":"#Static-Traits","page":"Home","title":"Static Traits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The size along one or more dimensions of an array may be known at compile time. ArrayInterface.known_size is useful for extracting this information from array types and ArrayInterface.size is useful for extracting this information from an instance of an array. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = ones(3)';\n\njulia> ArrayInterface.size(a)\n(static(1), 3)\n\njulia> ArrayInterface.known_size(typeof(a))\n(1, nothing)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is useful for dispatching on known information about the size of an array:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fxn(x) = _fxn(ArrayInterface.size(x), x)\n_fxn(sz::Tuple{StaticInt{S1},StaticInt{S2}}, x) where {S1,S2} = ...\n_fxn(sz::Tuple{StaticInt{3},StaticInt{3}}, x) = ...\n_fxn(sz::Tuple{Int,StaticInt{S2}}, x) where {S2} = ...\n_fxn(sz::Tuple{StaticInt{S1},Int}, x) where {S1} = ...\n_fxn(sz::Tuple{Int,Int}, x) = ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Methods should avoid forcing conversion to static sizes when dynamic sizes could potentially be returned. Fore example, fxn(x) = _fxn(Static.static(ArrayInterface.size(x)), x) would result in dynamic dispatch if x is an instance of Matrix. Additionally, ArrayInterface.size should only be used outside of generated functions to avoid possible world age issues.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generally, ArrayInterface.size uses the return of known_size to form a static value for those dimensions with known length and only queries dimensions corresponding to nothing. For example, the previous example had a known size of (1, nothing). Therefore, ArrayInterface.size would have compile time information about the first dimension returned as static(1) and would only look up the size of the second dimension at run time. This means the above example ArrayInterface.size(a) would lower to code similar to this at compile time: Static.StaticInt(1), Base.arraysize(x, 1). Generic support for ArrayInterface.known_size relies on calling known_length for each type returned from axes_types. Therefore, the recommended approach for supporting static sizing in newly defined array types is defining a new axes_types method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Static information related to subtypes of AbstractRange include known_length, known_first, known_step, and known_last.","category":"page"},{"location":"#Dimensions","page":"Home","title":"Dimensions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Methods such as size(x, dim) need to map dim to the dimensions of x. Typically, dim is an Int with an invariant mapping to the dimensions of x. Some methods accept : or a tuple of dimensions as an argument. ArrayInterface also considers StaticInt a viable dimension argument.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayInterface.to_dims helps ensure that dim is converted to a viable dimension mapping in a manner that helps with type stability. For example, all Integers passed to to_dims are converted to Int (unless dim is a StaticInt). This is also useful for arrays that uniquely label dimensions, in which case to_dims serves as a safe point of hooking into existing methods with dimension arguments. ArrayInterface also defines native Symbol to Int and StaticSymbol to StaticInt mapping  for arrays defining ArrayInterface.dimnames.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Methods requiring dimension specific arguments should use some variation of the following pattern.","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x, dim) = f(x, ArrayInterface.to_dims(x, dim))\nf(x, dim::Int) = ...\nf(x, dim::StaticInt) = ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"If x's first dimension is named :dim_1 then calling f(x, :dim_1) would result in f(x, 1). If users knew they always wanted to call f(x, 2) then they could define h(x) = f(x, static(2)), ensuring f passes along that information while compiling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"New types defining dimension names can do something similar to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Static\nusing ArrayInterface\n\nstruct StaticDimnames{dnames} end  # where dnames::Tuple{Vararg{Symbol}}\n\nArrayInterface.known_dimnames(::Type{StaticDimnames{dnames}}) where {dnames} = dnames\nArrayInterface.dimnames(::StaticDimnames{dnames}) where {dnames} = static(dnames)\n\nstruct DynamicDimnames{N}\n    dimnames::NTuple{N,Symbol}\nend\nArrayInterface.known_dimnames(::Type{DynamicDimnames{N}}) where {N} = ntuple(_-> nothing, Val(N))\nArrayInterface.dimnames(x::DynamicDimnames) = getfield(x, :dimnames)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that DynamicDimnames returns nothing instead of a symbol for each dimension. This indicates dimension names are present for DynamicDimnames but that information is nothing at compile time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dimension names should be appropriately propagated between nested arrays using ArrayInterface.to_parent_dims.  This allows types such as SubArray and PermutedDimsArray to work with named dimensions. Similarly, other methods that return information corresponding to dimensions (e.g., ArrayInterfce.size, ArrayInterface.axes) use to_parent_dims to appropriately propagate parent information.","category":"page"},{"location":"#Axes","page":"Home","title":"Axes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Where Julia's currently documented array interface requires defining Base.size, ArrayInterface instead requires defining ArrayInterface.axes and ArrayInterface.axes_types. ArrayInterface.axes_types(::Type{T}) facilitates propagation of a number of traits known at compile time (e.g., known_size, known_offsets) and ArrayInterface.axes(::AbstractArray) replaces Base.OneTo with ArrayInterface.OptionallyStaticUnitRange in situations where static information would otherwise be lost. ArrayInterface.axes(::AbstractArray, dim) utilizes to_dims, as described elsewhere.","category":"page"},{"location":"#Simple-Wrappers","page":"Home","title":"Simple Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's say we have a new array type doesn't affect axes then this is as simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base.axes(x::SimpleWrapper) = ArrayInterface.axes(parent(x))\nBase.axes(x::SimpleWrapper, dim) = ArrayInterface.axes(parent(x), dim)\nArrayInterface.axes_types(::Type{T}) where {T<:SimpleWrapper} = axes_types(parent_type(T))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To reiterate, ArrayInterface.axes improves on Base.axes for few Base array types but is otherwise identical. Therefore, the first method simply ensures you don't have to define multiple parametric methods for your new type to preserve statically sized nested axes (e.g., SimpleWrapper{T,N,<:Transpose{T,<:AbstractVector}}). This is otherwise identical to standard inheritance by composition.","category":"page"},{"location":"#When-to-Discard-Axis-Information","page":"Home","title":"When to Discard Axis Information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Occasionally the parent array's axis information can't be preserved. For example, we can't map axis information from the parent array of Base.ReshapedArray. In this case we can simply build axes from the new size information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayInterface.axes_types(T::Type{<:ReshapedArray}) = NTuple{ndims(T),OneTo{Int}}\nArrayInterface.axes(A::ReshapedArray) = map(OneTo, size(A))","category":"page"},{"location":"#New-Axis-Types","page":"Home","title":"New Axis Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OffsetArray changes the first index for each axis. It produces axes of type IdOffsetRange, which contains the value of the relative offset and the parent axis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ArrayInterface: axes_types, parent_type, to_dims\n# Note that generating a `Tuple` type piecewise like may be type unstable and should be\n# tested using `Test.@inferred`. It's often necessary to use generated function\n# (`@generated`) or methods defined in Static.jl.\n@generated function ArrayInterface.axes_types(::Type{A}) where {A<:OffsetArray}\n    out = Expr(:curly, :Tuple)\n    P = parent_type(A)\n    for dim in 1:ndims(A)\n        # offset relative to parent array\n        O = relative_known_offsets(A, dim)\n        if O === nothing  # offset is not known at compile time and is an `Int`\n            push!(out.args, :(IdOffsetRange{Int, axes_types($P, $(static(dim)))}))\n        else # offset is known, therefore it is a `StaticInt`\n            push!(out.args, :(IdOffsetRange{StaticInt{$O}, axes_types($P, $(static(dim))}))\n        end\n    end\nend\nfunction Base.axes(A::OffsetArray)\n    map(IdOffsetRange, ArrayInterface.axes(parent(A)), relative_offsets(A))\nend\nfunction Base.axes(A::OffsetArray, dim)\n    d = to_dims(A, dim)\n    IdOffsetRange(ArrayInterface.axes(parent(A), d), relative_offsets(A, d))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Defining these two methods ensures that other array types that wrap OffsetArray and appropriately define these methods propagate offsets independent of any dependency on OffsetArray. It is entirely optional to define ArrayInterface.size for OffsetArray because the size can be derived from the axes. However, in this particularly case we should also define  ArrayInterface.size(A::OffsetArray)  = ArrayInterface.size(parent(A)) because the relative offsets attached to OffsetArray do not change the size but may hide static sizes if using a relative offset that is defined with an Int.","category":"page"},{"location":"#Processing-Indices-(to_indices)","page":"Home","title":"Processing Indices (to_indices)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For most users, the only reason you should use ArrayInterface.to_indices over Base.to_indices is that it's faster and perhaps some of the more detailed benefits described in the to_indices doc string. For those interested in how this is accomplished, the following steps (beginning with the to_indices(A::AbstractArray, I::Tuple)) are used to accomplish this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The number of dimensions that each indexing argument in I corresponds to is determined using using the ndims_index and is_splat_index traits.\nA non-allocating reference to each axis of A is created (lazy_axes(A) -> axs). These are aligned to each the index arguments using information from the first step. For example, if an index argument maps to a single dimension then it is paired with axs[dim]. In the case of multiple dimensions it is paired with CartesianIndices(axs[dim_1], ... axs[dim_n]). These pairs are further processed using to_index(axis, I[n]).\nTuples returned from to_index are flattened out so that there are no nested tuples returned from to_indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Entry points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"to_indices(::ArrayType, indices) : dispatch on unique array type ArrayType\nto_index(axis, ::IndexType) : dispatch on a unique indexing type, IndexType. ArrayInterface.ndims_index(::Type{IndexType}) should also be defined in this case.\nto_index(S::IndexStyle, axis, index) : The index style S that corresponds to axis. This is ","category":"page"}]
}
