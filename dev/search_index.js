var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArrayInterface","category":"page"},{"location":"#ArrayInterface","page":"Home","title":"ArrayInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ArrayInterface]","category":"page"},{"location":"#ArrayInterface.ArrayIndex","page":"Home","title":"ArrayInterface.ArrayIndex","text":"ArrayIndex{N}\n\nSubtypes of ArrayIndex represent series of transformations for a provided index to some buffer which is typically accomplished with square brackets (e.g., buffer[index[inds...]]). The only behavior that is required of a subtype of ArrayIndex is the ability to transform individual index elements (i.e. not collections). This does not guarantee bounds checking or the ability to iterate (although additional functionallity may be provided for specific types).\n\n\n\n\n\n","category":"type"},{"location":"#ArrayInterface.BroadcastAxis","page":"Home","title":"ArrayInterface.BroadcastAxis","text":"BroadcastAxis\n\nAn abstract trait that is used to determine how axes are combined when calling broadcast_axis.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayInterface.LazyAxis","page":"Home","title":"ArrayInterface.LazyAxis","text":"LazyAxis{N}(parent::AbstractArray)\n\nA lazy representation of axes(parent, N).\n\n\n\n\n\n","category":"type"},{"location":"#ArrayInterface.OptionallyStaticStepRange","page":"Home","title":"ArrayInterface.OptionallyStaticStepRange","text":"OptionallyStaticStepRange(start, step, stop) <: OrdinalRange{Int,Int}\n\nSimilarly to OptionallyStaticUnitRange, OptionallyStaticStepRange permits a combination of static and standard primitive Ints to construct a range. It specifically enables the use of ranges without a step size of 1. It may be constructed through the use of OptionallyStaticStepRange directly or using static integers with the range operator (i.e., :).\n\njulia> using ArrayInterface\n\njulia> x = ArrayInterface.StaticInt(2);\n\njulia> x:x:10\nArrayInterface.StaticInt{2}():ArrayInterface.StaticInt{2}():10\n\njulia> ArrayInterface.OptionallyStaticStepRange(x, x, 10)\nArrayInterface.StaticInt{2}():ArrayInterface.StaticInt{2}():10\n\n\n\n\n\n","category":"type"},{"location":"#ArrayInterface.OptionallyStaticUnitRange","page":"Home","title":"ArrayInterface.OptionallyStaticUnitRange","text":"OptionallyStaticUnitRange(start, stop) <: AbstractUnitRange{Int}\n\nThis range permits diverse representations of arrays to communicate common information about their indices. Each field may be an integer or Val(<:Integer) if it is known at compile time. An OptionallyStaticUnitRange is intended to be constructed internally from other valid indices. Therefore, users should not expect the same checks are used to ensure construction of a valid OptionallyStaticUnitRange as a UnitRange.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayInterface.StrideIndex","page":"Home","title":"ArrayInterface.StrideIndex","text":"StrideIndex(x)\n\nSubtype of ArrayIndex that transforms and index using stride layout information derived from x.\n\n\n\n\n\n","category":"type"},{"location":"#ArrayInterface.allowed_getindex-Tuple{Any,Vararg{Any,N} where N}","page":"Home","title":"ArrayInterface.allowed_getindex","text":"allowed_getindex(x,i...)\n\nA scalar getindex which is always allowed.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.allowed_setindex!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Home","title":"ArrayInterface.allowed_setindex!","text":"allowed_setindex!(x,v,i...)\n\nA scalar setindex! which is always allowed.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.aos_to_soa-Tuple{Any}","page":"Home","title":"ArrayInterface.aos_to_soa","text":"aos_to_soa(x)\n\nConverts an array of structs formulation to a struct of array.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.axes-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.axes","text":"axes(A, d)\n\nReturn a valid range that maps to each index along dimension d of A.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.axes-Union{Tuple{A}, Tuple{A}} where A","page":"Home","title":"ArrayInterface.axes","text":"axes(A)\n\nReturn a tuple of ranges where each range maps to each element along a dimension of A.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.axes_types-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.axes_types","text":"axes_types(::Type{T}, dim)\n\nReturns the axis type along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.axes_types-Tuple{Any}","page":"Home","title":"ArrayInterface.axes_types","text":"axes_types(::Type{T}) -> Type\n\nReturns the type of the axes for T\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.broadcast_axis-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.broadcast_axis","text":"broadcast_axis(x, y)\n\nBroadcast axis x and y into a common space. The resulting axis should be equal in length to both x and y unless one has a length of 1, in which case the longest axis will be equal to the output.\n\njulia> ArrayInterface.broadcast_axis(1:10, 1:10)\n\njulia> ArrayInterface.broadcast_axis(1:10, 1)\n1:10\n\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.can_avx-Tuple{Any}","page":"Home","title":"ArrayInterface.can_avx","text":"can_avx(f) -> Bool\n\nReturns true if the function f is guaranteed to be compatible with LoopVectorization.@avx for supported element and array types. While a return value of false does not indicate the function isn't supported, this allows a library to conservatively apply @avx only when it is known to be safe to do so.\n\nfunction mymap!(f, y, args...)\n    if can_avx(f)\n        @avx @. y = f(args...)\n    else\n        @. y = f(args...)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.can_change_size-Tuple{Any}","page":"Home","title":"ArrayInterface.can_change_size","text":"can_change_size(::Type{T}) -> Bool\n\nReturns true if the Base.size of T can change, in which case operations such as pop! and popfirst! are available for collections of type T.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.can_setindex-Tuple{Any}","page":"Home","title":"ArrayInterface.can_setindex","text":"can_setindex(x::DataType)\n\nQuery whether a type can use setindex!.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.canonicalize-Tuple{Any}","page":"Home","title":"ArrayInterface.canonicalize","text":"canonicalize(x)\n\nChecks if x is in a canonical form for indexing. If x is already in a canonical form then it is returned unchanged. If x is not in a canonical form then it is passed to canonical_convert.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.contiguous_axis-Tuple{Any}","page":"Home","title":"ArrayInterface.contiguous_axis","text":"contiguous_axis(::Type{T}) -> StaticInt{N}\n\nReturns the axis of an array of type T containing contiguous data. If no axis is contiguous, it returns a StaticInt{-1}. If unknown, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.contiguous_axis_indicator-Union{Tuple{Type{A}}, Tuple{A}, Tuple{D}} where A<:(AbstractArray{#s15,D} where #s15) where D","page":"Home","title":"ArrayInterface.contiguous_axis_indicator","text":"contiguous_axis_indicator(::Type{T}) -> Tuple{Vararg{StaticBool}}\n\nReturns a tuple boolean Vals indicating whether that axis is contiguous.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.contiguous_batch_size-Tuple{Any}","page":"Home","title":"ArrayInterface.contiguous_batch_size","text":"contiguous_batch_size(::Type{T}) -> StaticInt{N}\n\nReturns the Base.size of contiguous batches if !isone(stride_rank(T, contiguous_axis(T))). If isone(stride_rank(T, contiguous_axis(T))), then it will return StaticInt{0}(). If contiguous_axis(T) == -1, it will return StaticInt{-1}(). If unknown, it will return nothing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.defines_strides-Tuple{Any}","page":"Home","title":"ArrayInterface.defines_strides","text":"defines_strides(::Type{T}) -> Bool\n\nIs strides(::T) defined? It is assumed that types returning true also return a valid pointer on pointer(::T).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.deleteat-Tuple{AbstractArray{T,1} where T,Any}","page":"Home","title":"ArrayInterface.deleteat","text":"deleteat(collection, index)\n\nReturns a new instance of collection with the item at the given index removed.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.dense_dims-Tuple{Any}","page":"Home","title":"ArrayInterface.dense_dims","text":"dense_dims(::Type{<:AbstractArray{N}}) -> NTuple{N,StaticBool}\n\nReturns a tuple of indicators for whether each axis is dense. An axis i of array A is dense if stride(A, i) * Base.size(A, i) == stride(A, j) where stride_rank(A)[i] + 1 == stride_rank(A)[j].\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.device-Tuple{Any}","page":"Home","title":"ArrayInterface.device","text":"device(::Type{T})\n\nIndicates the most efficient way to access elements from the collection in low-level code. For GPUArrays, will return ArrayInterface.GPU(). For AbstractArray supporting a pointer method, returns ArrayInterface.CPUPointer(). For other AbstractArrays and Tuples, returns ArrayInterface.CPUIndex(). Otherwise, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.dimnames-Tuple{Any}","page":"Home","title":"ArrayInterface.dimnames","text":"dimnames(::Type{T})::Tuple{Vararg{StaticSymbol}}\ndimnames(::Type{T}, dim)::StaticSymbol\n\nReturn the names of the dimensions for x.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.fast_matrix_colors-Tuple{Any}","page":"Home","title":"ArrayInterface.fast_matrix_colors","text":"fast_matrix_colors(A)\n\nQuery whether a matrix has a fast algorithm for getting the structural colors of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.fast_scalar_indexing-Tuple{Any}","page":"Home","title":"ArrayInterface.fast_scalar_indexing","text":"fast_scalar_indexing(x)\n\nQuery whether an array type has fast scalar indexing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.findstructralnz-Tuple{LinearAlgebra.Diagonal}","page":"Home","title":"ArrayInterface.findstructralnz","text":"findstructralnz(x::AbstractArray)\n\nReturn: (I,J) #indexable objects Find sparsity pattern of special matrices, the same as the first two elements of findnz(::SparseMatrixCSC).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.from_parent_dims-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.from_parent_dims","text":"from_parent_dims(::Type{T}, dim)::Union{Int,StaticInt}\n\nReturns the mapping from child dimensions to parent dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.from_parent_dims-Tuple{Any}","page":"Home","title":"ArrayInterface.from_parent_dims","text":"from_parent_dims(::Type{T})::Tuple{Vararg{Union{Int,StaticInt}}}\n\nReturns the mapping from parent dimensions to child dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.getindex-Tuple{Any,Vararg{Any,N} where N}","page":"Home","title":"ArrayInterface.getindex","text":"ArrayInterface.getindex(A, args...)\n\nRetrieve the value(s) stored at the given key or index within a collection. Creating another instance of ArrayInterface.getindex should only be done by overloading A. Changing indexing based on a given argument from args should be done through, to_index, or to_axis.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.has_dimnames-Tuple{Any}","page":"Home","title":"ArrayInterface.has_dimnames","text":"has_dimnames(::Type{T})::Bool\n\nReturns true if x has names for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.has_parent-Tuple{Any}","page":"Home","title":"ArrayInterface.has_parent","text":"has_parent(::Type{T}) -> StaticBool\n\nReturns True if parent_type(T) a type unique to T.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.has_sparsestruct-Tuple{Any}","page":"Home","title":"ArrayInterface.has_sparsestruct","text":"has_sparsestruct(x::AbstractArray)\n\nDetermine whether findstructralnz accepts the parameter x.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.indices-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.indices","text":"indices(x, dim)\n\nGiven an array x, this returns the indices along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.indices-Tuple{Any,Tuple}","page":"Home","title":"ArrayInterface.indices","text":"indices(x, dim::Tuple) -> Tuple{Vararg{AbstractUnitRange}}\n\nReturns valid indices for array x along each dimension specified in dim.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.indices-Tuple{Any}","page":"Home","title":"ArrayInterface.indices","text":"indices(x) -> AbstractUnitRange\n\nReturns valid indices for the entire length of x.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.indices-Tuple{Tuple,Any}","page":"Home","title":"ArrayInterface.indices","text":"indices(x::Tuple, dim) -> AbstractUnitRange\n\nReturns valid indices for each array in x along dimension dim\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.indices-Tuple{Tuple,Tuple}","page":"Home","title":"ArrayInterface.indices","text":"indices(x::Tuple, dim::Tuple) -> AbstractUnitRange\n\nReturns valid indices given a tuple of arrays x and tuple of dimesions for each respective array (dim).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.indices-Tuple{Tuple}","page":"Home","title":"ArrayInterface.indices","text":"indices(x::Tuple) -> AbstractUnitRange\n\nReturns valid indices for the entire length of each array in x.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.insert-Tuple{Any,Any,Any}","page":"Home","title":"ArrayInterface.insert","text":"insert(collection, index, item)\n\nReturns a new instance of collection with item inserted into at the given index.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.is_canonical-Tuple{Any}","page":"Home","title":"ArrayInterface.is_canonical","text":"is_canonical(::Type{I})::StaticBool\n\nReturns True if instances of I can be used for indexing without any further change (e.g., Int, StaticInt, UnitRange{Int})\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.is_column_major-Tuple{Any}","page":"Home","title":"ArrayInterface.is_column_major","text":"is_column_major(A) -> True/False\n\nReturns True() if elements of A are stored in column major order. Otherwise returns False().\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.is_lazy_conjugate-Union{Tuple{T}, Tuple{T}} where T<:AbstractArray","page":"Home","title":"ArrayInterface.is_lazy_conjugate","text":"is_lazy_conjugate(::AbstractArray)\n\nDetermine if a given array will lazyily take complex conjugates, such as with Adjoint. This will work with nested wrappers, so long as there is no type in the chain of wrappers such that parent_type(T) == T\n\nExamples\n\njulia> a = transpose([1 + im, 1-im]')\n2×1 transpose(adjoint(::Vector{Complex{Int64}})) with eltype Complex{Int64}:\n 1 - 1im\n 1 + 1im\n\njulia> ArrayInterface.is_lazy_conjugate(a)\nTrue()\n\njulia> b = a'\n1×2 adjoint(transpose(adjoint(::Vector{Complex{Int64}}))) with eltype Complex{Int64}:\n 1+1im  1-1im\n\njulia> ArrayInterface.is_lazy_conjugate(b)\nFalse()\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.ismutable-Tuple{Any}","page":"Home","title":"ArrayInterface.ismutable","text":"ismutable(x::DataType)\n\nQuery whether a type is mutable or not, see https://github.com/JuliaDiffEq/RecursiveArrayTools.jl/issues/19.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.issingular-Tuple{AbstractArray{T,2} where T}","page":"Home","title":"ArrayInterface.issingular","text":"issingular(A::AbstractMatrix)\n\nDetermine whether a given abstract matrix is singular.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.isstructured-Tuple{Any}","page":"Home","title":"ArrayInterface.isstructured","text":"isstructured(x::DataType)\n\nQuery whether a type is a representation of a structured matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_first-Tuple{Any}","page":"Home","title":"ArrayInterface.known_first","text":"known_first(::Type{T})\n\nIf first of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> ArrayInterface.known_first(typeof(1:4))\nnothing\n\njulia> ArrayInterface.known_first(typeof(Base.OneTo(4)))\n1\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_last-Tuple{Any}","page":"Home","title":"ArrayInterface.known_last","text":"known_last(::Type{T})\n\nIf last of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> ArrayInterface.known_last(typeof(1:4))\nnothing\n\njulia> ArrayInterface.known_first(typeof(static(1):static(4)))\n4\n\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_length-Tuple{Any}","page":"Home","title":"ArrayInterface.known_length","text":"known_length(::Type{T})\n\nIf length of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_offset1-Tuple{Any}","page":"Home","title":"ArrayInterface.known_offset1","text":"known_offset1(x) -> Union{Int,Nothing}\n\nReturns the linear offset of array x if known at compile time.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_offsets-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.known_offsets","text":"known_offsets(::Type{T}[, dim]) -> Tuple\n\nReturns a tuple of offset values known at compile time. If the offset of a given axis is not known at compile time nothing is returned its position.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_size-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.known_size","text":"known_size(::Type{T}, dim)\n\nReturns the size along dimension dim known at compile time. If it is not known then returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_size-Tuple{Any}","page":"Home","title":"ArrayInterface.known_size","text":"known_size(::Type{T}) -> Tuple\n\nReturns the size of each dimension for T known at compile time. If a dimension does not have a known size along a dimension then nothing is returned in its position.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_step-Tuple{Any}","page":"Home","title":"ArrayInterface.known_step","text":"known_step(::Type{T})\n\nIf step of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> ArrayInterface.known_step(typeof(1:2:8))\nnothing\n\njulia> ArrayInterface.known_step(typeof(1:4))\n1\n\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.known_strides-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.known_strides","text":"known_strides(::Type{T}[, dim]) -> Tuple\n\nReturns the strides of array A known at compile time. Any strides that are not known at compile time are represented by nothing.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.lazy_axes-Union{Tuple{X}, Tuple{X}} where X","page":"Home","title":"ArrayInterface.lazy_axes","text":"lazy_axes(x)\n\nProduces a tuple of axes where each axis is constructed lazily. If an axis of x is already constructed or it is simply retrieved.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.lu_instance-Tuple{Any}","page":"Home","title":"ArrayInterface.lu_instance","text":"lu_instance(a::Any) -> lu(a, check=false)\n\nReturns the number.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.lu_instance-Tuple{Number}","page":"Home","title":"ArrayInterface.lu_instance","text":"lu_instance(a::Number) -> a\n\nReturns the number.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.lu_instance-Union{Tuple{Array{T,2}}, Tuple{T}} where T","page":"Home","title":"ArrayInterface.lu_instance","text":"luinstance(A) -> lufactorization_instance\n\nReturns an instance of the LU factorization object with the correct type cheaply.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.matrix_colors-Tuple{Union{Array, LinearAlgebra.LowerTriangular, LinearAlgebra.UpperTriangular}}","page":"Home","title":"ArrayInterface.matrix_colors","text":"matrix_colors(A::Union{Array,UpperTriangular,LowerTriangular})\n\nThe color vector for dense matrix and triangular matrix is simply [1,2,3,..., Base.size(A,2)].\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.offset1-Union{Tuple{X}, Tuple{X}} where X","page":"Home","title":"ArrayInterface.offset1","text":"offset1(x) -> Integer\n\nReturns the offset of the linear indices for x.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.offsets-Tuple{ArrayInterface.StrideIndex}","page":"Home","title":"ArrayInterface.offsets","text":"offsets(A[, dim]) -> Tuple\n\nReturns offsets of indices with respect to 0. If values are known at compile time, it should return them as Static numbers. For example, if A isa Base.Matrix, offsets(A) === (StaticInt(1), StaticInt(1)).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.parent_type-Tuple{Any}","page":"Home","title":"ArrayInterface.parent_type","text":"parent_type(::Type{T})\n\nReturns the parent array that type T wraps.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.reduce_tup-Union{Tuple{N}, Tuple{F}, Tuple{F,Tuple{Vararg{Any,N}}}} where N where F","page":"Home","title":"ArrayInterface.reduce_tup","text":"reduce_tup(f::F, inds::Tuple{Vararg{Any,N}}) where {F,N}\n\nAn optimized reduce for tuples. Base.reduce's afoldl will often not inline. Additionally, reduce_tup attempts to order the reduction in an optimal manner.\n\njulia> using StaticArrays, ArrayInterface, BenchmarkTools\n\njulia> rsum(v::SVector) = ArrayInterface.reduce_tup(+, v.data)\nrsum (generic function with 2 methods)\n\njulia> for n ∈ 2:16\n           @show n\n           v = @SVector rand(n)\n           s1 = @btime  sum($(Ref(v))[])\n           s2 = @btime rsum($(Ref(v))[])\n       end\nn = 2\n  0.863 ns (0 allocations: 0 bytes)\n  0.863 ns (0 allocations: 0 bytes)\nn = 3\n  0.862 ns (0 allocations: 0 bytes)\n  0.863 ns (0 allocations: 0 bytes)\nn = 4\n  0.862 ns (0 allocations: 0 bytes)\n  0.862 ns (0 allocations: 0 bytes)\nn = 5\n  1.074 ns (0 allocations: 0 bytes)\n  0.864 ns (0 allocations: 0 bytes)\nn = 6\n  0.864 ns (0 allocations: 0 bytes)\n  0.862 ns (0 allocations: 0 bytes)\nn = 7\n  1.075 ns (0 allocations: 0 bytes)\n  0.864 ns (0 allocations: 0 bytes)\nn = 8\n  1.077 ns (0 allocations: 0 bytes)\n  0.865 ns (0 allocations: 0 bytes)\nn = 9\n  1.081 ns (0 allocations: 0 bytes)\n  0.865 ns (0 allocations: 0 bytes)\nn = 10\n  1.195 ns (0 allocations: 0 bytes)\n  0.867 ns (0 allocations: 0 bytes)\nn = 11\n  1.357 ns (0 allocations: 0 bytes)\n  1.400 ns (0 allocations: 0 bytes)\nn = 12\n  1.543 ns (0 allocations: 0 bytes)\n  1.074 ns (0 allocations: 0 bytes)\nn = 13\n  1.702 ns (0 allocations: 0 bytes)\n  1.077 ns (0 allocations: 0 bytes)\nn = 14\n  1.913 ns (0 allocations: 0 bytes)\n  0.867 ns (0 allocations: 0 bytes)\nn = 15\n  2.076 ns (0 allocations: 0 bytes)\n  1.077 ns (0 allocations: 0 bytes)\nn = 16\n  2.273 ns (0 allocations: 0 bytes)\n  1.078 ns (0 allocations: 0 bytes)\n\nMore importantly, reduce_tup(_pick_range, inds) often performs better than reduce(_pick_range, inds).\n\njulia> using ArrayInterface, BenchmarkTools\n\njulia> inds = (Base.OneTo(100), 1:100, 1:ArrayInterface.StaticInt(100))\n(Base.OneTo(100), 1:100, 1:Static(100))\n\njulia> @btime reduce(ArrayInterface._pick_range, $(Ref(inds))[])\n  6.405 ns (0 allocations: 0 bytes)\nBase.Slice(Static(1):Static(100))\n\njulia> @btime ArrayInterface.reduce_tup(ArrayInterface._pick_range, $(Ref(inds))[])\n  2.570 ns (0 allocations: 0 bytes)\nBase.Slice(Static(1):Static(100))\n\njulia> inds = (Base.OneTo(100), 1:100, 1:UInt(100))\n(Base.OneTo(100), 1:100, 0x0000000000000001:0x0000000000000064)\n\njulia> @btime reduce(ArrayInterface._pick_range, $(Ref(inds))[])\n  6.411 ns (0 allocations: 0 bytes)\nBase.Slice(Static(1):100)\n\njulia> @btime ArrayInterface.reduce_tup(ArrayInterface._pick_range, $(Ref(inds))[])\n  2.592 ns (0 allocations: 0 bytes)\nBase.Slice(Static(1):100)\n\njulia> inds = (Base.OneTo(100), 1:100, 1:UInt(100), Int32(1):Int32(100))\n(Base.OneTo(100), 1:100, 0x0000000000000001:0x0000000000000064, 1:100)\n\njulia> @btime reduce(ArrayInterface._pick_range, $(Ref(inds))[])\n  9.048 ns (0 allocations: 0 bytes)\nBase.Slice(Static(1):100)\n\njulia> @btime ArrayInterface.reduce_tup(ArrayInterface._pick_range, $(Ref(inds))[])\n  2.569 ns (0 allocations: 0 bytes)\nBase.Slice(Static(1):100)\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.restructure-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.restructure","text":"restructure(x,y)\n\nRestructures the object y into a shape of x, keeping its values intact. For simple objects like an Array, this simply amounts to a reshape. However, for more complex objects such as an ArrayPartition, not all of the structural information is adequately contained in the type for standard tools to work. In these cases, restructure gives a way to convert for example an Array into a matching ArrayPartition.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.safevec-Tuple{Any}","page":"Home","title":"ArrayInterface.safevec","text":"safevec(v)\n\nIt is a form of vec which is safe for all values in vector spaces, i.e., if it is already a vector, like an AbstractVector or Number, it will return said AbstractVector or Number.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.setindex!-Tuple{Any,Any,Vararg{Any,N} where N}","page":"Home","title":"ArrayInterface.setindex!","text":"ArrayInterface.setindex!(A, args...)\n\nStore the given values at the given key or index within a collection.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.size-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.size","text":"size(A, dim)\n\nReturns the size of A along dimension dim.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.size-Union{Tuple{A}, Tuple{A}} where A","page":"Home","title":"ArrayInterface.size","text":"size(A)\n\nReturns the size of A. If the size of any axes are known at compile time, these should be returned as Static numbers. For example:\n\njulia> using StaticArrays, ArrayInterface\n\njulia> A = @SMatrix rand(3,4);\n\njulia> ArrayInterface.size(A)\n(StaticInt{3}(), StaticInt{4}())\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.strides-Tuple{ArrayInterface.StrideIndex}","page":"Home","title":"ArrayInterface.strides","text":"strides(A) -> Tuple\n\nReturns the strides of array A. If any strides are known at compile time, these should be returned as Static numbers. For example:\n\njulia> A = rand(3,4);\n\njulia> ArrayInterface.strides(A)\n(static(1), 3)\n\nAdditionally, the behavior differs from Base.strides for adjoint vectors:\n\njulia> x = rand(5);\n\njulia> ArrayInterface.strides(x')\n(static(1), static(1))\n\nThis is to support the pattern of using just the first stride for linear indexing, x[i], while still producing correct behavior when using valid cartesian indices, such as x[1,i]. ```\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_axes-Tuple{Any,Tuple}","page":"Home","title":"ArrayInterface.to_axes","text":"to_axes(A, inds)\n\nConstruct new axes given the corresponding inds constructed after to_indices(A, args) -> inds. This method iterates through each pair of axes and indices calling to_axis.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_axis-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.to_axis","text":"to_axis(old_axis, index) -> new_axis\n\nConstruct an new_axis for a newly constructed array that corresponds to the previously executed to_index(old_axis, arg) -> index. to_axis assumes that index has already been confirmed to be in bounds. The underlying indices of new_axis begins at one and extends the length of index (i.e., one-based indexing).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_dims-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.to_dims","text":"to_dims(::Type{T}, dim)::Union{Int,StaticInt}\n\nThis returns the dimension(s) of x corresponding to d.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_index-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.to_index","text":"to_index([::IndexStyle, ]axis, arg) -> index\n\nConvert the argument arg that was originally passed to getindex for the dimension corresponding to axis into a form for native indexing (Int, Vector{Int}, etc.). New axis types with unique behavior should use an IndexStyle trait:\n\nto_index(axis::MyAxisType, arg) = to_index(IndexStyle(axis), axis, arg)\nto_index(::MyIndexStyle, axis, arg) = ...\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_indices-Tuple{Any,Tuple{}}","page":"Home","title":"ArrayInterface.to_indices","text":"to_indices(A, inds::Tuple)::Tuple\n\nMaps indexing arguments inds to the axes of A, ensures they are converted to a native indexing form, and that they are inbounds. Unless all indices in inds return static(true) on a call to is_canonical, then they each are checked at the axis level with to_index.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_parent_dims-Tuple{Any,Any}","page":"Home","title":"ArrayInterface.to_parent_dims","text":"to_parent_dims(::Type{T}, dim)::Union{Int,StaticInt}\n\nReturns the mapping from child dimensions to parent dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.to_parent_dims-Tuple{Any}","page":"Home","title":"ArrayInterface.to_parent_dims","text":"to_parent_dims(::Type{T})::Tuple{Vararg{Union{Int,StaticInt}}}\n\nReturns the mapping from child dimensions to parent dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.unsafe_reconstruct-Tuple{Base.OneTo,Any}","page":"Home","title":"ArrayInterface.unsafe_reconstruct","text":"unsafe_reconstruct(A, data; kwargs...)\n\nReconstruct A given the values in data. New methods using unsafe_reconstruct should only dispatch on A.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayInterface.zeromatrix-Tuple{Any}","page":"Home","title":"ArrayInterface.zeromatrix","text":"zeromatrix(u::AbstractVector)\n\nCreates the zero'd matrix version of u. Note that this is unique because similar(u,length(u),length(u)) returns a mutable type, so it is not type-matching, while fill(zero(eltype(u)),length(u),length(u)) doesn't match the array type, i.e., you'll get a CPU array from a GPU array. The generic fallback is u .* u' .* false, which works on a surprising number of types, but can be broken with weird (recursive) broadcast overloads. For higher-order tensors, this returns the matrix linear operator type which acts on the vec of the array.\n\n\n\n\n\n","category":"method"},{"location":"#Static-Traits","page":"Home","title":"Static Traits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The size along one or more dimensions of an array may be known at compile time.  ArrayInterface.known_size is useful for extracting this information from array types and ArrayInterface.size is useful for extracting this information from an instance of an array. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = ones(3)';\n\njulia> ArrayInterface.size(a)\n(static(1), 3)\n\njulia> ArrayInterface.known_size(typeof(a))\n(1, nothing)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is useful for dispatching on known information about the size of an array:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fxn(x) = _fxn(ArrayInterface.size(x), x)\n_fxn(sz::Tuple{StaticInt{S1},StaticInt{S2}}, x) where {S1,S2} = ...\n_fxn(sz::Tuple{StaticInt{3},StaticInt{3}}, x) = ...\n_fxn(sz::Tuple{Int,StaticInt{S2}}, x) where {S2} = ...\n_fxn(sz::Tuple{StaticInt{S1},Int}, x) where {S1} = ...\n_fxn(sz::Tuple{Int,Int}, x) = ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Methods should avoid forcing conversion to static sizes when dynamic sizes could potentially be returned. Fore example, fxn(x) = _fxn(Static.static(ArrayInterface.size(x)), x) would result in dynamic dispatch if x is an instance of Matrix. Additionally, ArrayInterface.size should only be used outside of generated functions to avoid possible world age issues.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generally, ArrayInterface.size uses the return of known_size to form a static value for those dimensions with known length and only queries dimensions corresponding to nothing. For example, the previous example had a known size of (1, nothing). Therefore, ArrayInterface.size would have compile time information about the first dimension returned as static(1) and would only look up the size of the second dimension at run time. Generic support for ArrayInterface.known_size relies on calling known_length for each type returned from axes_types. Therefore, the recommended approach for supporting static sizing in newly defined array types is defining a new axes_types method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Static information related to subtypes of AbstractRange include known_length, known_first, known_step, and known_last.","category":"page"}]
}
