var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#ArrayInterfaceCore.jl","page":"API","title":"ArrayInterfaceCore.jl","text":"","category":"section"},{"location":"api/#Traits","page":"API","title":"Traits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterfaceCore.can_avx\nArrayInterfaceCore.can_change_size\nArrayInterfaceCore.can_setindex\nArrayInterfaceCore.device\nArrayInterfaceCore.defines_strides\nArrayInterfaceCore.fast_matrix_colors\nArrayInterfaceCore.fast_scalar_indexing\nArrayInterfaceCore.is_forwarding_wrapper\nArrayInterfaceCore.ismutable\nArrayInterfaceCore.isstructured\nArrayInterfaceCore.has_sparsestruct\nArrayInterfaceCore.ndims_index\nArrayInterfaceCore.ndims_shape\n","category":"page"},{"location":"api/#ArrayInterfaceCore.can_avx","page":"API","title":"ArrayInterfaceCore.can_avx","text":"can_avx(f) -> Bool\n\nReturns true if the function f is guaranteed to be compatible with LoopVectorization.@avx for supported element and array types. While a return value of false does not indicate the function isn't supported, this allows a library to conservatively apply @avx only when it is known to be safe to do so.\n\nfunction mymap!(f, y, args...)\n    if can_avx(f)\n        @avx @. y = f(args...)\n    else\n        @. y = f(args...)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.can_change_size","page":"API","title":"ArrayInterfaceCore.can_change_size","text":"can_change_size(::Type{T}) -> Bool\n\nReturns true if the Base.size of T can change, in which case operations such as pop! and popfirst! are available for collections of type T.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.can_setindex","page":"API","title":"ArrayInterfaceCore.can_setindex","text":"can_setindex(::Type{T}) -> Bool\n\nQuery whether a type can use setindex!.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.device","page":"API","title":"ArrayInterfaceCore.device","text":"device(::Type{T}) -> AbstractDevice\n\nIndicates the most efficient way to access elements from the collection in low-level code. For GPUArrays, will return ArrayInterface.GPU(). For AbstractArray supporting a pointer method, returns ArrayInterface.CPUPointer(). For other AbstractArrays and Tuples, returns ArrayInterface.CPUIndex(). Otherwise, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.defines_strides","page":"API","title":"ArrayInterfaceCore.defines_strides","text":"defines_strides(::Type{T}) -> Bool\n\nIs strides(::T) defined? It is assumed that types returning true also return a valid pointer on pointer(::T).\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.fast_matrix_colors","page":"API","title":"ArrayInterfaceCore.fast_matrix_colors","text":"fast_matrix_colors(A)\n\nQuery whether a matrix has a fast algorithm for getting the structural colors of the matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.fast_scalar_indexing","page":"API","title":"ArrayInterfaceCore.fast_scalar_indexing","text":"fast_scalar_indexing(::Type{T}) -> Bool\n\nQuery whether an array type has fast scalar indexing.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.is_forwarding_wrapper","page":"API","title":"ArrayInterfaceCore.is_forwarding_wrapper","text":"is_forwarding_wrapper(::Type{T}) -> Bool\n\nReturns true if the type T wraps another data type and does not alter any of its standard interface. For example, if T were an array then its size, indices, and elements would all be equivalent to its wrapped data.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.ismutable","page":"API","title":"ArrayInterfaceCore.ismutable","text":"ismutable(::Type{T}) -> Bool\n\nQuery whether instances of type T are mutable or not, see https://github.com/JuliaDiffEq/RecursiveArrayTools.jl/issues/19.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.isstructured","page":"API","title":"ArrayInterfaceCore.isstructured","text":"isstructured(::Type{T}) -> Bool\n\nQuery whether a type is a representation of a structured matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.has_sparsestruct","page":"API","title":"ArrayInterfaceCore.has_sparsestruct","text":"has_sparsestruct(x::AbstractArray) -> Bool\n\nDetermine whether findstructralnz accepts the parameter x.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.ndims_index","page":"API","title":"ArrayInterfaceCore.ndims_index","text":"ndims_index(::Type{I}) -> Int\n\nReturns the number of dimensions that an instance of I indexes into. If this method is not explicitly defined, then 1 is returned.\n\nSee also ndims_shape\n\nExamples\n\njulia> ArrayInterfaceCore.ndims_index(Int)\n1\n\njulia> ArrayInterfaceCore.ndims_index(CartesianIndex(1, 2, 3))\n3\n\njulia> ArrayInterfaceCore.ndims_index([CartesianIndex(1, 2), CartesianIndex(1, 3)])\n2\n\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.ndims_shape","page":"API","title":"ArrayInterfaceCore.ndims_shape","text":"ndims_shape(::Type{I}) -> Union{Int,Tuple{Vararg{Int}}}\n\nReturns the number of dimension that are represented in the shape of the returned array when indexing with an instance of I.\n\nSee also ndims_index\n\nExamples\n\n```julia julia> ArrayInterfaceCore.ndims_shape([CartesianIndex(1, 1), CartesianIndex(1, 2)]) 1\n\njulia> ndims(CartesianIndices((2,2))[[CartesianIndex(1, 1), CartesianIndex(1, 2)]]) 1\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterfaceCore.allowed_getindex\nArrayInterfaceCore.allowed_setindex!\nArrayInterfaceCore.aos_to_soa\nArrayInterfaceCore.buffer\nArrayInterfaceCore.findstructralnz\nArrayInterfaceCore.lu_instance\nArrayInterfaceCore.matrix_colors\nArrayInterfaceCore.issingular\nArrayInterfaceCore.parent_type\nArrayInterfaceCore.restructure\nArrayInterfaceCore.safevec\nArrayInterfaceCore.zeromatrix","category":"page"},{"location":"api/#ArrayInterfaceCore.allowed_getindex","page":"API","title":"ArrayInterfaceCore.allowed_getindex","text":"allowed_getindex(x,i...)\n\nA scalar getindex which is always allowed.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.allowed_setindex!","page":"API","title":"ArrayInterfaceCore.allowed_setindex!","text":"allowed_setindex!(x,v,i...)\n\nA scalar setindex! which is always allowed.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.aos_to_soa","page":"API","title":"ArrayInterfaceCore.aos_to_soa","text":"aos_to_soa(x)\n\nConverts an array of structs formulation to a struct of array.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.buffer","page":"API","title":"ArrayInterfaceCore.buffer","text":"buffer(x)\n\nReturn the buffer data that x points to. Unlike parent(x::AbstractArray), buffer(x) may not return another array type.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.findstructralnz","page":"API","title":"ArrayInterfaceCore.findstructralnz","text":"findstructralnz(x::AbstractArray)\n\nReturn: (I,J) #indexable objects Find sparsity pattern of special matrices, the same as the first two elements of findnz(::SparseMatrixCSC).\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.lu_instance","page":"API","title":"ArrayInterfaceCore.lu_instance","text":"luinstance(A) -> lufactorization_instance\n\nReturns an instance of the LU factorization object with the correct type cheaply.\n\n\n\n\n\nlu_instance(a::Number) -> a\n\nReturns the number.\n\n\n\n\n\nlu_instance(a::Any) -> lu(a, check=false)\n\nReturns the number.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.matrix_colors","page":"API","title":"ArrayInterfaceCore.matrix_colors","text":"matrix_colors(A::Union{Array,UpperTriangular,LowerTriangular})\n\nThe color vector for dense matrix and triangular matrix is simply [1,2,3,..., Base.size(A,2)].\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.issingular","page":"API","title":"ArrayInterfaceCore.issingular","text":"issingular(A::AbstractMatrix) -> Bool\n\nDetermine whether a given abstract matrix is singular.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.parent_type","page":"API","title":"ArrayInterfaceCore.parent_type","text":"parent_type(::Type{T}) -> Type\n\nReturns the parent array that type T wraps.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.restructure","page":"API","title":"ArrayInterfaceCore.restructure","text":"restructure(x,y)\n\nRestructures the object y into a shape of x, keeping its values intact. For simple objects like an Array, this simply amounts to a reshape. However, for more complex objects such as an ArrayPartition, not all of the structural information is adequately contained in the type for standard tools to work. In these cases, restructure gives a way to convert for example an Array into a matching ArrayPartition.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.safevec","page":"API","title":"ArrayInterfaceCore.safevec","text":"safevec(v)\n\nIt is a form of vec which is safe for all values in vector spaces, i.e., if it is already a vector, like an AbstractVector or Number, it will return said AbstractVector or Number.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.zeromatrix","page":"API","title":"ArrayInterfaceCore.zeromatrix","text":"zeromatrix(u::AbstractVector)\n\nCreates the zero'd matrix version of u. Note that this is unique because similar(u,length(u),length(u)) returns a mutable type, so it is not type-matching, while fill(zero(eltype(u)),length(u),length(u)) doesn't match the array type, i.e., you'll get a CPU array from a GPU array. The generic fallback is u .* u' .* false, which works on a surprising number of types, but can be broken with weird (recursive) broadcast overloads. For higher-order tensors, this returns the matrix linear operator type which acts on the vec of the array.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterfaceCore.ArrayIndex\nArrayInterfaceCore.GetIndex\nArrayInterfaceCore.SetIndex!","category":"page"},{"location":"api/#ArrayInterfaceCore.ArrayIndex","page":"API","title":"ArrayInterfaceCore.ArrayIndex","text":"ArrayIndex{N}\n\nSubtypes of ArrayIndex represent series of transformations for a provided index to some buffer which is typically accomplished with square brackets (e.g., buffer[index[inds...]]). The only behavior that is required of a subtype of ArrayIndex is the ability to transform individual index elements (i.e. not collections). This does not guarantee bounds checking or the ability to iterate (although additional functionallity may be provided for specific types).\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterfaceCore.GetIndex","page":"API","title":"ArrayInterfaceCore.GetIndex","text":"GetIndex(buffer) = GetIndex{true}(buffer)\nGetIndex{check}(buffer) -> g\n\nWraps an indexable buffer in a function type that is indexed when called, so that g(inds..) is equivalent to buffer[inds...]. If check is false, then all indexing arguments are considered in-bounds. The default value for check is true, requiring bounds checking for each index.\n\nSee also SetIndex!\n\n!!! Warning     Passing false as check may result in incorrect results/crashes/corruption for     out-of-bounds indices, similar to inappropriate use of @inbounds. The user is     responsible for ensuring this is correctly used.\n\nExamples\n\njulia> ArrayInterfaceCore.GetIndex(1:10)(3)\n3\n\njulia> ArrayInterfaceCore.GetIndex{false}(1:10)(11)  # shouldn't be in-bounds\n11\n\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterfaceCore.SetIndex!","page":"API","title":"ArrayInterfaceCore.SetIndex!","text":"SetIndex!(buffer) = SetIndex!{true}(buffer)\nSetIndex!{check}(buffer) -> g\n\nWraps an indexable buffer in a function type that sets a value at an index when called, so that g(val, inds..) is equivalent to setindex!(buffer, val, inds...). If check is false, then all indexing arguments are considered in-bounds. The default value for check is true, requiring bounds checking for each index.\n\nSee also GetIndex\n\n!!! Warning     Passing false as check may result in incorrect results/crashes/corruption for     out-of-bounds indices, similar to inappropriate use of @inbounds. The user is     responsible for ensuring this is correctly used.\n\nExamples\n\n\njulia> x = [1, 2, 3, 4];\n\njulia> ArrayInterface.SetIndex!(x)(10, 2);\n\njulia> x[2]\n10\n\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterface.jl","page":"API","title":"ArrayInterface.jl","text":"","category":"section"},{"location":"api/#Traits-2","page":"API","title":"Traits","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterface.contiguous_axis\nArrayInterface.contiguous_axis_indicator\nArrayInterface.contiguous_batch_size\nArrayInterface.dimnames\nArrayInterface.has_dimnames\nArrayInterface.has_parent\nArrayInterface.is_column_major\nArrayInterface.is_lazy_conjugate\nArrayInterface.is_splat_index\nArrayInterface.known_dimnames\nArrayInterface.known_first\nArrayInterface.known_last\nArrayInterface.known_length\nArrayInterface.known_offset1\nArrayInterface.known_offsets\nArrayInterface.known_size\nArrayInterface.known_step\nArrayInterface.known_strides","category":"page"},{"location":"api/#ArrayInterface.contiguous_axis","page":"API","title":"ArrayInterface.contiguous_axis","text":"contiguous_axis(::Type{T}) -> StaticInt{N}\n\nReturns the axis of an array of type T containing contiguous data. If no axis is contiguous, it returns a StaticInt{-1}. If unknown, it returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.contiguous_axis_indicator","page":"API","title":"ArrayInterface.contiguous_axis_indicator","text":"contiguous_axis_indicator(::Type{T}) -> Tuple{Vararg{StaticBool}}\n\nReturns a tuple boolean Vals indicating whether that axis is contiguous.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.contiguous_batch_size","page":"API","title":"ArrayInterface.contiguous_batch_size","text":"contiguous_batch_size(::Type{T}) -> StaticInt{N}\n\nReturns the Base.size of contiguous batches if !isone(stride_rank(T, contiguous_axis(T))). If isone(stride_rank(T, contiguous_axis(T))), then it will return StaticInt{0}(). If contiguous_axis(T) == -1, it will return StaticInt{-1}(). If unknown, it will return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.dimnames","page":"API","title":"ArrayInterface.dimnames","text":"dimnames(x) -> Tuple{Vararg{Union{Symbol,StaticSymbol}}}\ndimnames(x, dim::Union{Int,StaticInt}) -> Union{Symbol,StaticSymbol}\n\nReturn the names of the dimensions for x. :_ is used to indicate a dimension does not have a name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.has_dimnames","page":"API","title":"ArrayInterface.has_dimnames","text":"has_dimnames(::Type{T}) -> Bool\n\nReturns true if x has on or more named dimensions. If all dimensions correspond to :_, then false is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.has_parent","page":"API","title":"ArrayInterface.has_parent","text":"has_parent(::Type{T}) -> StaticBool\n\nReturns static(true) if parent_type(T) a type unique to T.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.is_column_major","page":"API","title":"ArrayInterface.is_column_major","text":"is_column_major(A) -> StaticBool\n\nReturns True() if elements of A are stored in column major order. Otherwise returns False().\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.is_lazy_conjugate","page":"API","title":"ArrayInterface.is_lazy_conjugate","text":"is_lazy_conjugate(::AbstractArray) -> Bool\n\nDetermine if a given array will lazyily take complex conjugates, such as with Adjoint. This will work with nested wrappers, so long as there is no type in the chain of wrappers such that parent_type(T) == T\n\nExamples\n\njulia> a = transpose([1 + im, 1-im]')\n2×1 transpose(adjoint(::Vector{Complex{Int64}})) with eltype Complex{Int64}:\n 1 - 1im\n 1 + 1im\n\njulia> ArrayInterface.is_lazy_conjugate(a)\nTrue()\n\njulia> b = a'\n1×2 adjoint(transpose(adjoint(::Vector{Complex{Int64}}))) with eltype Complex{Int64}:\n 1+1im  1-1im\n\njulia> ArrayInterface.is_lazy_conjugate(b)\nFalse()\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.is_splat_index","page":"API","title":"ArrayInterfaceCore.is_splat_index","text":"is_splat_index(::Type{T}) -> Bool\n\nReturns static(true) if T is a type that splats across multiple dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.known_dimnames","page":"API","title":"ArrayInterface.known_dimnames","text":"known_dimnames(::Type{T}) -> Tuple{Vararg{Union{Symbol,Nothing}}}\nknown_dimnames(::Type{T}, dim::Union{Int,StaticInt}) -> Union{Symbol,Nothing}\n\nReturn the names of the dimensions for x. :_ is used to indicate a dimension does not have a name.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.known_first","page":"API","title":"ArrayInterfaceCore.known_first","text":"known_first(::Type{T}) -> Union{Int,Nothing}\n\nIf first of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> ArrayInterface.known_first(typeof(1:4))\nnothing\n\njulia> ArrayInterface.known_first(typeof(Base.OneTo(4)))\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.known_last","page":"API","title":"ArrayInterfaceCore.known_last","text":"known_last(::Type{T}) -> Union{Int,Nothing}\n\nIf last of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> ArrayInterfaceCore.known_last(typeof(1:4))\nnothing\n\njulia> ArrayInterfaceCore.known_first(typeof(static(1):static(4)))\n4\n\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.known_length","page":"API","title":"ArrayInterface.known_length","text":"known_length(::Type{T}) -> Union{Int,Nothing}\n\nIf length of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.known_offset1","page":"API","title":"ArrayInterface.known_offset1","text":"known_offset1(::Type{T}) -> Union{Int,Nothing}\n\nReturns the linear offset of array x if known at compile time.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.known_offsets","page":"API","title":"ArrayInterface.known_offsets","text":"known_offsets(::Type{T}) -> Tuple\nknown_offsets(::Type{T}, dim) -> Union{Int,Nothing}\n\nReturns a tuple of offset values known at compile time. If the offset of a given axis is not known at compile time nothing is returned its position.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.known_size","page":"API","title":"ArrayInterface.known_size","text":"known_size(::Type{T}) -> Tuple\nknown_size(::Type{T}, dim) -> Union{Int,Nothing}\n\nReturns the size of each dimension of A or along dimension dim of A that is known at compile time. If a dimension does not have a known size along a dimension then nothing is returned in its position.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterfaceCore.known_step","page":"API","title":"ArrayInterfaceCore.known_step","text":"known_step(::Type{T}) -> Union{Int,Nothing}\n\nIf step of an instance of type T is known at compile time, return it. Otherwise, return nothing.\n\njulia> ArrayInterface.known_step(typeof(1:2:8))\nnothing\n\njulia> ArrayInterface.known_step(typeof(1:4))\n1\n\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.known_strides","page":"API","title":"ArrayInterface.known_strides","text":"known_strides(::Type{T}) -> Tuple\nknown_strides(::Type{T}, dim) -> Union{Int,Nothing}\n\nReturns the strides of array A known at compile time. Any strides that are not known at compile time are represented by nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-2","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterface.axes\nArrayInterface.axes_types\nArrayInterface.broadcast_axis\nArrayInterface.deleteat\nArrayInterface.dense_dims\nArrayInterface.from_parent_dims\nArrayInterface.getindex\nArrayInterface.indices\nArrayInterface.insert\nArrayInterface.lazy_axes\nArrayInterface.offset1\nArrayInterface.offsets\nArrayInterface.setindex!\nArrayInterface.size\nArrayInterface.strides\nArrayInterface.to_axes\nArrayInterface.to_axis\nArrayInterface.to_dims\nArrayInterface.to_index\nArrayInterface.to_indices\nArrayInterface.to_parent_dims\nArrayInterface.unsafe_reconstruct","category":"page"},{"location":"api/#ArrayInterface.axes","page":"API","title":"ArrayInterface.axes","text":"axes(A) -> Tuple{Vararg{AbstractUnitRange{Int}}}\naxes(A, dim) -> AbstractUnitRange{Int}\n\nReturns the axis associated with each dimension of A or dimension dim. ArrayInterface.axes(::AbstractArray) behaves nearly identical to Base.axes with the exception of a handful of types replace Base.OneTo{Int} with ArrayInterface.SOneTo. For example, the axis along the first dimension of Transpose{T,<:AbstractVector{T}} and Adjoint{T,<:AbstractVector{T}} can be represented by SOneTo(1). Similarly, Base.ReinterpretArray's first axis may be statically sized.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.axes_types","page":"API","title":"ArrayInterface.axes_types","text":"axes_types(::Type{T}) -> Type{Tuple{Vararg{AbstractUnitRange{Int}}}}\naxes_types(::Type{T}, dim) -> Type{AbstractUnitRange{Int}}\n\nReturns the type of each axis for the T, or the type of of the axis along dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.broadcast_axis","page":"API","title":"ArrayInterface.broadcast_axis","text":"broadcast_axis(x, y)\n\nBroadcast axis x and y into a common space. The resulting axis should be equal in length to both x and y unless one has a length of 1, in which case the longest axis will be equal to the output.\n\njulia> ArrayInterface.broadcast_axis(1:10, 1:10)\n\njulia> ArrayInterface.broadcast_axis(1:10, 1)\n1:10\n\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.deleteat","page":"API","title":"ArrayInterface.deleteat","text":"deleteat(collection, index)\n\nReturns a new instance of collection with the item at the given index removed.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.dense_dims","page":"API","title":"ArrayInterface.dense_dims","text":"dense_dims(::Type{<:AbstractArray{N}}) -> Tuple{Vararg{StaticBool,N}}\n\nReturns a tuple of indicators for whether each axis is dense. An axis i of array A is dense if stride(A, i) * Base.size(A, i) == stride(A, j) where stride_rank(A)[i] + 1 == stride_rank(A)[j].\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.from_parent_dims","page":"API","title":"ArrayInterface.from_parent_dims","text":"from_parent_dims(::Type{T}) -> Tuple{Vararg{Union{StaticInt,Tuple{Vararg{StaticInt}}}}}\n\nReturns the mapping from parent dimensions to child dimensions.\n\n!!! Warning     This method is still experimental and may change without notice.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.getindex","page":"API","title":"ArrayInterface.getindex","text":"ArrayInterface.getindex(A, args...)\n\nRetrieve the value(s) stored at the given key or index within a collection. Creating another instance of ArrayInterface.getindex should only be done by overloading A. Changing indexing based on a given argument from args should be done through, to_index, or to_axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.indices","page":"API","title":"ArrayInterface.indices","text":"indices(x, dim) -> AbstractUnitRange{Int}\n\nGiven an array x, this returns the indices along dimension dim.\n\n\n\n\n\nindices(x) -> AbstractUnitRange{Int}\n\nReturns valid indices for the entire length of x.\n\n\n\n\n\nindices(x::Tuple) -> AbstractUnitRange{Int}\n\nReturns valid indices for the entire length of each array in x.\n\n\n\n\n\nindices(x::Tuple, dim)  -> AbstractUnitRange{Int}\n\nReturns valid indices for each array in x along dimension dim\n\n\n\n\n\nindices(x::Tuple, dim::Tuple) -> AbstractUnitRange{Int}\n\nReturns valid indices given a tuple of arrays x and tuple of dimesions for each respective array (dim).\n\n\n\n\n\nindices(x, dim::Tuple) -> Tuple{Vararg{AbstractUnitRange{Int}}}\n\nReturns valid indices for array x along each dimension specified in dim.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.insert","page":"API","title":"ArrayInterface.insert","text":"insert(collection, index, item)\n\nReturns a new instance of collection with item inserted into at the given index.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.lazy_axes","page":"API","title":"ArrayInterface.lazy_axes","text":"lazy_axes(x)\n\nProduces a tuple of axes where each axis is constructed lazily. If an axis of x is already constructed or it is simply retrieved.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.offset1","page":"API","title":"ArrayInterface.offset1","text":"offset1(x) -> Union{Int,StaticInt}\n\nReturns the offset of the linear indices for x.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.offsets","page":"API","title":"ArrayInterface.offsets","text":"offsets(A) -> Tuple\noffsets(A, dim) -> Union{Int,StaticInt}\n\nReturns offsets of indices with respect to 0. If values are known at compile time, it should return them as Static numbers. For example, if A isa Base.Matrix, offsets(A) === (StaticInt(1), StaticInt(1)).\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.setindex!","page":"API","title":"ArrayInterface.setindex!","text":"ArrayInterface.setindex!(A, args...)\n\nStore the given values at the given key or index within a collection.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.size","page":"API","title":"ArrayInterface.size","text":"size(A) -> Tuple\nsize(A, dim) -> Union{Int,StaticInt}\n\nReturns the size of each dimension of A or along dimension dim of A. If the size of any axes are known at compile time, these should be returned as Static numbers. Otherwise, ArrayInterface.size(A) is identical to Base.size(A)\n\njulia> using StaticArrays, ArrayInterface\n\njulia> A = @SMatrix rand(3,4);\n\njulia> ArrayInterface.size(A)\n(static(3), static(4))\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.strides","page":"API","title":"ArrayInterface.strides","text":"strides(A) -> Tuple{Vararg{Union{Int,StaticInt}}}\nstrides(A, dim) -> Union{Int,StaticInt}\n\nReturns the strides of array A. If any strides are known at compile time, these should be returned as Static numbers. For example:\n\njulia> A = rand(3,4);\n\njulia> ArrayInterface.strides(A)\n(static(1), 3)\n\nAdditionally, the behavior differs from Base.strides for adjoint vectors:\n\njulia> x = rand(5);\n\njulia> ArrayInterface.strides(x')\n(static(1), static(1))\n\nThis is to support the pattern of using just the first stride for linear indexing, x[i], while still producing correct behavior when using valid cartesian indices, such as x[1,i]. ```\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.to_axes","page":"API","title":"ArrayInterface.to_axes","text":"to_axes(A, inds) -> Tuple\n\nConstruct new axes given the corresponding inds constructed after to_indices(A, args) -> inds. This method iterates through each pair of axes and indices calling to_axis.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.to_axis","page":"API","title":"ArrayInterface.to_axis","text":"to_axis(old_axis, index) -> new_axis\n\nConstruct an new_axis for a newly constructed array that corresponds to the previously executed to_index(old_axis, arg) -> index. to_axis assumes that index has already been confirmed to be in bounds. The underlying indices of new_axis begins at one and extends the length of index (i.e., one-based indexing).\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.to_dims","page":"API","title":"ArrayInterface.to_dims","text":"to_dims(x, dim) -> Union{Int,StaticInt}\n\nThis returns the dimension(s) of x corresponding to dim.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.to_index","page":"API","title":"ArrayInterface.to_index","text":"ArrayInterface.to_index([::IndexStyle, ]axis, arg) -> index\n\nConvert the argument arg that was originally passed to ArrayInterface.getindex for the dimension corresponding to axis into a form for native indexing (Int, Vector{Int}, etc.).\n\nArrayInterface.to_index supports passing a function as an index. This function-index is transformed into a proper index.\n\njulia> using ArrayInterface, Static\n\njulia> ArrayInterface.to_index(static(1):static(10), 5)\n5\n\njulia> ArrayInterface.to_index(static(1):static(10), <(5))\nstatic(1):4\n\njulia> ArrayInterface.to_index(static(1):static(10), <=(5))\nstatic(1):5\n\njulia> ArrayInterface.to_index(static(1):static(10), >(5))\n6:static(10)\n\njulia> ArrayInterface.to_index(static(1):static(10), >=(5))\n5:static(10)\n\n\nUse of a function-index helps ensure that indices are inbounds\n\njulia> ArrayInterface.to_index(static(1):static(10), <(12))\nstatic(1):10\n\njulia> ArrayInterface.to_index(static(1):static(10), >(-1))\n1:static(10)\n\nNew axis types with unique behavior should use an IndexStyle trait:\n\nto_index(axis::MyAxisType, arg) = to_index(IndexStyle(axis), axis, arg)\nto_index(::MyIndexStyle, axis, arg) = ...\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.to_indices","page":"API","title":"ArrayInterface.to_indices","text":"ArrayInterface.to_indices(A, I::Tuple) -> Tuple\n\nConverts the tuple of indexing arguments, I, into an appropriate form for indexing into A. Typically, each index should be an Int, StaticInt, a collection with values of Int, or a collection with values of CartesianIndex This is accomplished in three steps after the initial call to to_indices:\n\nExtended help\n\nThis implementation differs from that of Base.to_indices in the following ways:\n\nto_indices(A, I) never results in recursive processing of I through to_indices(A, axes(A), I). This is avoided through the use of an internal @generated method that aligns calls of to_indices and to_index based on the return values of ndims_index. This is beneficial because the compiler currently does not optimize away the increased time spent recursing through   each additional argument that needs converting. For example:   ```julia   julia> x = rand(4,4,4,4,4,4,4,4,4,4);\njulia> inds1 = (1, 2, 1, 2, 1, 2, 1, 2, 1, 2);\njulia> inds2 = (1, CartesianIndex(1, 2), 1, CartesianIndex(1, 2), 1, CartesianIndex(1, 2), 1);\njulia> inds3 = (fill(true, 4, 4), 2, fill(true, 4, 4), 2, 1, fill(true, 4, 4), 1);\njulia> @btime Base.to_indices(x, inds2)   1.105 μs (12 allocations: 672 bytes)   (1, 1, 2, 1, 1, 2, 1, 1, 2, 1)\njulia> @btime ArrayInterface.to_indices(x, inds2)   0.041 ns (0 allocations: 0 bytes)   (1, 1, 2, 1, 1, 2, 1, 1, 2, 1)\njulia> @btime Base.to_indices(x, inds3);   340.629 ns (14 allocations: 768 bytes)\njulia> @btime ArrayInterface.to_indices(x, inds3);   11.614 ns (0 allocations: 0 bytes)\n```\nRecursing through to_indices(A, axes, I::Tuple{I1,Vararg{Any}}) is intended to provide context for processing I1. However, this doesn't tell use how many dimensions are consumed by what is in Vararg{Any}. Using ndims_index to directly align the axes of A with each value in I ensures that a CartesiaIndex{3} at the tail of I isn't incorrectly assumed to only consume one dimension.\nBase.to_indices may fail to infer the returned type. This is the case for inds2 and inds3 in the first bullet on Julia 1.6.4.\nSpecializing by dispatch through method definitions like this: to_indices(::ArrayType, ::Tuple{AxisType,Vararg{Any}}, ::Tuple{::IndexType,Vararg{Any}}) require an excessive number of hand written methods to avoid ambiguities. Furthermore, if AxisType is wrapping another axis that should have unique behavior, then unique parametric types need to also be explicitly defined.\nto_index(axes(A, dim), index) is called, as opposed to Base.to_index(A, index). The IndexStyle of the resulting axis is used to allow indirect dispatch on nested axis types within to_index.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.to_parent_dims","page":"API","title":"ArrayInterface.to_parent_dims","text":"to_parent_dims(::Type{T}) -> Tuple{Vararg{Union{StaticInt,Tuple{Vararg{StaticInt}}}}}\n\nReturns the mapping from child dimensions to parent dimensions.\n\n!!! Warning     This method is still experimental and may change without notice.\n\n\n\n\n\n","category":"function"},{"location":"api/#ArrayInterface.unsafe_reconstruct","page":"API","title":"ArrayInterface.unsafe_reconstruct","text":"unsafe_reconstruct(A, data; kwargs...)\n\nReconstruct A given the values in data. New methods using unsafe_reconstruct should only dispatch on A.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types-2","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ArrayInterface.BroadcastAxis\nArrayInterface.LazyAxis\nArrayInterface.OptionallyStaticStepRange\nArrayInterface.OptionallyStaticUnitRange\nArrayInteraface.SOneTo\nArrayInteraface.SUnitRange\nArrayInterface.StrideIndex","category":"page"},{"location":"api/#ArrayInterface.BroadcastAxis","page":"API","title":"ArrayInterface.BroadcastAxis","text":"BroadcastAxis\n\nAn abstract trait that is used to determine how axes are combined when calling broadcast_axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterface.LazyAxis","page":"API","title":"ArrayInterface.LazyAxis","text":"LazyAxis{N}(parent::AbstractArray)\n\nA lazy representation of axes(parent, N).\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterface.OptionallyStaticStepRange","page":"API","title":"ArrayInterface.OptionallyStaticStepRange","text":"OptionallyStaticStepRange(start, step, stop) <: OrdinalRange{Int,Int}\n\nSimilarly to OptionallyStaticUnitRange, OptionallyStaticStepRange permits a combination of static and standard primitive Ints to construct a range. It specifically enables the use of ranges without a step size of 1. It may be constructed through the use of OptionallyStaticStepRange directly or using static integers with the range operator (i.e., :).\n\njulia> using ArrayInterface\n\njulia> x = ArrayInterface.static(2);\n\njulia> x:x:10\nstatic(2):static(2):10\n\njulia> ArrayInterface.OptionallyStaticStepRange(x, x, 10)\nstatic(2):static(2):10\n\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterface.OptionallyStaticUnitRange","page":"API","title":"ArrayInterface.OptionallyStaticUnitRange","text":"OptionallyStaticUnitRange(start, stop) <: AbstractUnitRange{Int}\n\nSimilar to UnitRange except each field may be an Int or StaticInt. An OptionallyStaticUnitRange is intended to be constructed internally from other valid indices. Therefore, users should not expect the same checks are used to ensure construction of a valid OptionallyStaticUnitRange as a UnitRange.\n\n\n\n\n\n","category":"type"},{"location":"api/#ArrayInterface.StrideIndex","page":"API","title":"ArrayInterface.StrideIndex","text":"StrideIndex(x)\n\nSubtype of ArrayIndex that transforms and index using stride layout information derived from x.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArrayInterface","category":"page"},{"location":"#ArrayInterface","page":"Home","title":"ArrayInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Designs for new Base array interface primitives, used widely through scientific machine learning (SciML) and other organizations","category":"page"},{"location":"#ArrayInterfaceCore","page":"Home","title":"ArrayInterfaceCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArrayInterfaceCore is a smaller set of the ArrayInterface setup which defines the subset which has no compile time impact. This for example includes simple functions like ArrayInterfaceCore.zeromatrix which have simple few dispatch definitions and no dependency on other libraries such as Static.jl. Notably, Static.jl currently has issues with invalidations (https://github.com/SciML/Static.jl/issues/52), and thus anything with static outputs are in the domain of ArrayInterface.jl proprer.","category":"page"},{"location":"#Subpackages","page":"Home","title":"Subpackages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order to remove the runtime impact of Requires.jl, ArrayInterface.jl uses a subpackaging system for defining interface support for potential dependencies. These packages are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayInterfaceBandedMatrices.jl\nArrayInterfaceBlockBandedMatrices.jl\nArrayInterfaceCUDA.jl\nArrayInterfaceOffsetArrays.jl\nArrayInterfaceTracker.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order for ArrayInterface traits to be properly defined on these types, it is required that the downstream package depends on and imports the correct subpackages.","category":"page"},{"location":"#Inheriting-Array-Traits","page":"Home","title":"Inheriting Array Traits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creating an array type with unique behavior in Julia is often accomplished by creating a lazy wrapper around previously defined array types (e.g. composition by inheritance). This allows the new array type to inherit functionality by redirecting methods to the parent array (e.g., Base.size(x::Wrapper) = size(parent(x))). Generic design limits the need to define an excessive number of methods like this. However, methods used to describe a type's traits often need to be explicitly defined for each trait method. If the the underlying data and access to it are unchanged by it's wrapper the ArrayInterface.is_forwarding_wrapper trait can signal to other trait methods to access its parent data structure. Supporting this for a new type only requires defines these methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayInterface.is_forwarding_wrapper(::Type{<:NewType}) = true\nArrayInterface.parent_type(::Type{<:NewType}) = NewTypeParent\nBase.parent(x::NewType) = x.parent","category":"page"},{"location":"","page":"Home","title":"Home","text":"For those authoring new trait methods, this may change the default definition from has_trait(::Type{T}) where {T} = false, to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"function has_trait(::Type{T}) where {T}\n    if is_forwarding_wrapper(T)\n        return false\n    else\n        return has_trait(parent_type(T))\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most traits in ArrayInterface are a variant on this pattern. If the trait in question may be altered by a wrapper array, this pattern should be altered or may be inappropriate.","category":"page"},{"location":"#Static-Traits","page":"Home","title":"Static Traits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The size along one or more dimensions of an array may be known at compile time. ArrayInterface.known_size is useful for extracting this information from array types and ArrayInterface.size is useful for extracting this information from an instance of an array. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = ones(3)';\n\njulia> ArrayInterface.size(a)\n(static(1), 3)\n\njulia> ArrayInterface.known_size(typeof(a))\n(1, nothing)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is useful for dispatching on known information about the size of an array:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fxn(x) = _fxn(ArrayInterface.size(x), x)\n_fxn(sz::Tuple{StaticInt{S1},StaticInt{S2}}, x) where {S1,S2} = ...\n_fxn(sz::Tuple{StaticInt{3},StaticInt{3}}, x) = ...\n_fxn(sz::Tuple{Int,StaticInt{S2}}, x) where {S2} = ...\n_fxn(sz::Tuple{StaticInt{S1},Int}, x) where {S1} = ...\n_fxn(sz::Tuple{Int,Int}, x) = ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Methods should avoid forcing conversion to static sizes when dynamic sizes could potentially be returned. Fore example, fxn(x) = _fxn(Static.static(ArrayInterface.size(x)), x) would result in dynamic dispatch if x is an instance of Matrix. Additionally, ArrayInterface.size should only be used outside of generated functions to avoid possible world age issues.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generally, ArrayInterface.size uses the return of known_size to form a static value for those dimensions with known length and only queries dimensions corresponding to nothing. For example, the previous example had a known size of (1, nothing). Therefore, ArrayInterface.size would have compile time information about the first dimension returned as static(1) and would only look up the size of the second dimension at run time. This means the above example ArrayInterface.size(a) would lower to code similar to this at compile time: Static.StaticInt(1), Base.arraysize(x, 1). Generic support for ArrayInterface.known_size relies on calling known_length for each type returned from axes_types. Therefore, the recommended approach for supporting static sizing in newly defined array types is defining a new axes_types method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Static information related to subtypes of AbstractRange include known_length, known_first, known_step, and known_last.","category":"page"},{"location":"#Dimensions","page":"Home","title":"Dimensions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Methods such as size(x, dim) need to map dim to the dimensions of x. Typically, dim is an Int with an invariant mapping to the dimensions of x. Some methods accept : or a tuple of dimensions as an argument. ArrayInterface also considers StaticInt a viable dimension argument.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayInterface.to_dims helps ensure that dim is converted to a viable dimension mapping in a manner that helps with type stability. For example, all Integers passed to to_dims are converted to Int (unless dim is a StaticInt). This is also useful for arrays that uniquely label dimensions, in which case to_dims serves as a safe point of hooking into existing methods with dimension arguments. ArrayInterface also defines native Symbol to Int and StaticSymbol to StaticInt mapping  for arrays defining ArrayInterface.dimnames.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Methods requiring dimension specific arguments should use some variation of the following pattern.","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x, dim) = f(x, ArrayInterface.to_dims(x, dim))\nf(x, dim::Int) = ...\nf(x, dim::StaticInt) = ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"If x's first dimension is named :dim_1 then calling f(x, :dim_1) would result in f(x, 1). If users knew they always wanted to call f(x, 2) then they could define h(x) = f(x, static(2)), ensuring f passes along that information while compiling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"New types defining dimension names can do something similar to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Static\nusing ArrayInterface\n\nstruct StaticDimnames{dnames} end  # where dnames::Tuple{Vararg{Symbol}}\n\nArrayInterface.known_dimnames(::Type{StaticDimnames{dnames}}) where {dnames} = dnames\nArrayInterface.dimnames(::StaticDimnames{dnames}) where {dnames} = static(dnames)\n\nstruct DynamicDimnames{N}\n    dimnames::NTuple{N,Symbol}\nend\nArrayInterface.known_dimnames(::Type{DynamicDimnames{N}}) where {N} = ntuple(_-> nothing, Val(N))\nArrayInterface.dimnames(x::DynamicDimnames) = getfield(x, :dimnames)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that DynamicDimnames returns nothing instead of a symbol for each dimension. This indicates dimension names are present for DynamicDimnames but that information is nothing at compile time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dimension names should be appropriately propagated between nested arrays using ArrayInterface.to_parent_dims.  This allows types such as SubArray and PermutedDimsArray to work with named dimensions. Similarly, other methods that return information corresponding to dimensions (e.g., ArrayInterfce.size, ArrayInterface.axes) use to_parent_dims to appropriately propagate parent information.","category":"page"},{"location":"#Axes","page":"Home","title":"Axes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Where Julia's currently documented array interface requires defining Base.size, ArrayInterface instead requires defining ArrayInterface.axes and ArrayInterface.axes_types. ArrayInterface.axes_types(::Type{T}) facilitates propagation of a number of traits known at compile time (e.g., known_size, known_offsets) and ArrayInterface.axes(::AbstractArray) replaces Base.OneTo with ArrayInterface.OptionallyStaticUnitRange in situations where static information would otherwise be lost. ArrayInterface.axes(::AbstractArray, dim) utilizes to_dims, as described elsewhere.","category":"page"},{"location":"#Simple-Wrappers","page":"Home","title":"Simple Wrappers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's say we have a new array type doesn't affect axes then this is as simple as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base.axes(x::SimpleWrapper) = ArrayInterface.axes(parent(x))\nBase.axes(x::SimpleWrapper, dim) = ArrayInterface.axes(parent(x), dim)\nArrayInterface.axes_types(::Type{T}) where {T<:SimpleWrapper} = axes_types(parent_type(T))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To reiterate, ArrayInterface.axes improves on Base.axes for few Base array types but is otherwise identical. Therefore, the first method simply ensures you don't have to define multiple parametric methods for your new type to preserve statically sized nested axes (e.g., SimpleWrapper{T,N,<:Transpose{T,<:AbstractVector}}). This is otherwise identical to standard inheritance by composition.","category":"page"},{"location":"#When-to-Discard-Axis-Information","page":"Home","title":"When to Discard Axis Information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Occasionally the parent array's axis information can't be preserved. For example, we can't map axis information from the parent array of Base.ReshapedArray. In this case we can simply build axes from the new size information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArrayInterface.axes_types(T::Type{<:ReshapedArray}) = NTuple{ndims(T),OneTo{Int}}\nArrayInterface.axes(A::ReshapedArray) = map(OneTo, size(A))","category":"page"},{"location":"#New-Axis-Types","page":"Home","title":"New Axis Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OffsetArray changes the first index for each axis. It produces axes of type IdOffsetRange, which contains the value of the relative offset and the parent axis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ArrayInterface: axes_types, parent_type, to_dims\n# Note that generating a `Tuple` type piecewise like may be type unstable and should be\n# tested using `Test.@inferred`. It's often necessary to use generated function\n# (`@generated`) or methods defined in Static.jl.\n@generated function ArrayInterface.axes_types(::Type{A}) where {A<:OffsetArray}\n    out = Expr(:curly, :Tuple)\n    P = parent_type(A)\n    for dim in 1:ndims(A)\n        # offset relative to parent array\n        O = relative_known_offsets(A, dim)\n        if O === nothing  # offset is not known at compile time and is an `Int`\n            push!(out.args, :(IdOffsetRange{Int, axes_types($P, $(static(dim)))}))\n        else # offset is known, therefore it is a `StaticInt`\n            push!(out.args, :(IdOffsetRange{StaticInt{$O}, axes_types($P, $(static(dim))}))\n        end\n    end\nend\nfunction Base.axes(A::OffsetArray)\n    map(IdOffsetRange, ArrayInterface.axes(parent(A)), relative_offsets(A))\nend\nfunction Base.axes(A::OffsetArray, dim)\n    d = to_dims(A, dim)\n    IdOffsetRange(ArrayInterface.axes(parent(A), d), relative_offsets(A, d))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Defining these two methods ensures that other array types that wrap OffsetArray and appropriately define these methods propagate offsets independent of any dependency on OffsetArray. It is entirely optional to define ArrayInterface.size for OffsetArray because the size can be derived from the axes. However, in this particularly case we should also define  ArrayInterface.size(A::OffsetArray)  = ArrayInterface.size(parent(A)) because the relative offsets attached to OffsetArray do not change the size but may hide static sizes if using a relative offset that is defined with an Int.","category":"page"},{"location":"#Processing-Indices-(to_indices)","page":"Home","title":"Processing Indices (to_indices)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For most users, the only reason you should use ArrayInterface.to_indices over Base.to_indices is that it's faster and perhaps some of the more detailed benefits described in the to_indices doc string. For those interested in how this is accomplished, the following steps (beginning with the to_indices(A::AbstractArray, I::Tuple)) are used to accomplish this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The number of dimensions that each indexing argument in I corresponds to is determined using using the ndims_index and is_splat_index traits.\nA non-allocating reference to each axis of A is created (lazy_axes(A) -> axs). These are aligned to each the index arguments using information from the first step. For example, if an index argument maps to a single dimension then it is paired with axs[dim]. In the case of multiple dimensions it is paired with CartesianIndices(axs[dim_1], ... axs[dim_n]). These pairs are further processed using to_index(axis, I[n]).\nTuples returned from to_index are flattened out so that there are no nested tuples returned from to_indices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Entry points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"to_indices(::ArrayType, indices) : dispatch on unique array type ArrayType\nto_index(axis, ::IndexType) : dispatch on a unique indexing type, IndexType. ArrayInterface.ndims_index(::Type{IndexType}) should also be defined in this case.\nto_index(S::IndexStyle, axis, index) : The index style S that corresponds to axis. This is ","category":"page"}]
}
