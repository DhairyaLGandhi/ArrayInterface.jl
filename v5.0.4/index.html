<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ArrayInterface</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ArrayInterface</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Inheriting-Array-Traits"><span>Inheriting Array Traits</span></a></li><li><a class="tocitem" href="#Static-Traits"><span>Static Traits</span></a></li><li><a class="tocitem" href="#Dimensions"><span>Dimensions</span></a></li><li><a class="tocitem" href="#Axes"><span>Axes</span></a></li><li><a class="tocitem" href="#Processing-Indices-(to_indices)"><span>Processing Indices (<code>to_indices</code>)</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaArrays/ArrayInterface.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ArrayInterface"><a class="docs-heading-anchor" href="#ArrayInterface">ArrayInterface</a><a id="ArrayInterface-1"></a><a class="docs-heading-anchor-permalink" href="#ArrayInterface" title="Permalink"></a></h1><p>Designs for new Base array interface primitives, used widely through scientific machine learning (SciML) and other organizations</p><h2 id="Inheriting-Array-Traits"><a class="docs-heading-anchor" href="#Inheriting-Array-Traits">Inheriting Array Traits</a><a id="Inheriting-Array-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Inheriting-Array-Traits" title="Permalink"></a></h2><p>Creating an array type with unique behavior in Julia is often accomplished by creating a lazy wrapper around previously defined array types (e.g. <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition by inheritance</a>). This allows the new array type to inherit functionality by redirecting methods to the parent array (e.g., <code>Base.size(x::Wrapper) = size(parent(x))</code>). Generic design limits the need to define an excessive number of methods like this. However, methods used to describe a type&#39;s traits often need to be explicitly defined for each trait method. <code>ArrayInterface</code> assists with this by providing information about the parent type using <a href="api/#ArrayInterface.parent_type"><code>ArrayInterface.parent_type</code></a>. By default <code>ArrayInterface.parent_type(::Type{T})</code> returns <code>T</code> (analogous to <code>Base.parent(x) = x</code>). If any type other than <code>T</code> is returned we assume <code>T</code> wraps a parent structure, so methods know to unwrap instances of <code>T</code>. It is also assumed that if <code>T</code> has a parent type <code>Base.parent</code> is defined.</p><p>For those authoring new trait methods, this may change the default definition from <code>has_trait(::Type{T}) where {T} = false</code>, to:</p><pre><code class="language-julia hljs">function has_trait(::Type{T}) where {T}
    if parent_type(T) &lt;:T
        return false
    else
        return has_trait(parent_type(T))
    end
end</code></pre><p>Most traits in <code>ArrayInterface</code> are a variant on this pattern. If the trait in question may be altered by a wrapper array, this pattern should be altered or may be inappropriate.</p><h2 id="Static-Traits"><a class="docs-heading-anchor" href="#Static-Traits">Static Traits</a><a id="Static-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Static-Traits" title="Permalink"></a></h2><p>The size along one or more dimensions of an array may be known at compile time. <code>ArrayInterface.known_size</code> is useful for extracting this information from array types and <code>ArrayInterface.size</code> is useful for extracting this information from an instance of an array. For example:</p><pre><code class="language-julia hljs">julia&gt; a = ones(3)&#39;;

julia&gt; ArrayInterface.size(a)
(static(1), 3)

julia&gt; ArrayInterface.known_size(typeof(a))
(1, nothing)
</code></pre><p>This is useful for dispatching on known information about the size of an array:</p><pre><code class="language-julia hljs">fxn(x) = _fxn(ArrayInterface.size(x), x)
_fxn(sz::Tuple{StaticInt{S1},StaticInt{S2}}, x) where {S1,S2} = ...
_fxn(sz::Tuple{StaticInt{3},StaticInt{3}}, x) = ...
_fxn(sz::Tuple{Int,StaticInt{S2}}, x) where {S2} = ...
_fxn(sz::Tuple{StaticInt{S1},Int}, x) where {S1} = ...
_fxn(sz::Tuple{Int,Int}, x) = ...</code></pre><p>Methods should avoid forcing conversion to static sizes when dynamic sizes could potentially be returned. Fore example, <code>fxn(x) = _fxn(Static.static(ArrayInterface.size(x)), x)</code> would result in dynamic dispatch if <code>x</code> is an instance of <code>Matrix</code>. Additionally, <code>ArrayInterface.size</code> should only be used outside of generated functions to avoid possible world age issues.</p><p>Generally, <code>ArrayInterface.size</code> uses the return of <code>known_size</code> to form a static value for those dimensions with known length and only queries dimensions corresponding to <code>nothing</code>. For example, the previous example had a known size of <code>(1, nothing)</code>. Therefore, <code>ArrayInterface.size</code> would have compile time information about the first dimension returned as <code>static(1)</code> and would only look up the size of the second dimension at run time. This means the above example <code>ArrayInterface.size(a)</code> would lower to code similar to this at compile time: <code>Static.StaticInt(1), Base.arraysize(x, 1)</code>. Generic support for <code>ArrayInterface.known_size</code> relies on calling <code>known_length</code> for each type returned from <code>axes_types</code>. Therefore, the recommended approach for supporting static sizing in newly defined array types is defining a new <code>axes_types</code> method.</p><p>Static information related to subtypes of <code>AbstractRange</code> include <code>known_length</code>, <code>known_first</code>, <code>known_step</code>, and <code>known_last</code>.</p><h2 id="Dimensions"><a class="docs-heading-anchor" href="#Dimensions">Dimensions</a><a id="Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensions" title="Permalink"></a></h2><p>Methods such as <code>size(x, dim)</code> need to map <code>dim</code> to the dimensions of <code>x</code>. Typically, <code>dim</code> is an <code>Int</code> with an invariant mapping to the dimensions of <code>x</code>. Some methods accept <code>:</code> or a tuple of dimensions as an argument. <code>ArrayInterface</code> also considers <code>StaticInt</code> a viable dimension argument.</p><p><a href="api/#ArrayInterface.to_dims"><code>ArrayInterface.to_dims</code></a> helps ensure that <code>dim</code> is converted to a viable dimension mapping in a manner that helps with type stability. For example, all <code>Integers</code> passed to <code>to_dims</code> are converted to <code>Int</code> (unless <code>dim</code> is a <code>StaticInt</code>). This is also useful for arrays that uniquely label dimensions, in which case <code>to_dims</code> serves as a safe point of hooking into existing methods with dimension arguments. <code>ArrayInterface</code> also defines native <code>Symbol</code> to <code>Int</code> and <code>StaticSymbol</code> to <code>StaticInt</code> mapping  for arrays defining <a href="api/#ArrayInterface.dimnames"><code>ArrayInterface.dimnames</code></a>.</p><p>Methods requiring dimension specific arguments should use some variation of the following pattern.</p><pre><code class="language-julia hljs">f(x, dim) = f(x, ArrayInterface.to_dims(x, dim))
f(x, dim::Int) = ...
f(x, dim::StaticInt) = ...</code></pre><p>If <code>x</code>&#39;s first dimension is named <code>:dim_1</code> then calling <code>f(x, :dim_1)</code> would result in <code>f(x, 1)</code>. If users knew they always wanted to call <code>f(x, 2)</code> then they could define <code>h(x) = f(x, static(2))</code>, ensuring <code>f</code> passes along that information while compiling.</p><p>New types defining dimension names can do something similar to:</p><pre><code class="language-julia hljs">using Static
using ArrayInterface

struct StaticDimnames{dnames} end  # where dnames::Tuple{Vararg{Symbol}}

ArrayInterface.known_dimnames(::Type{StaticDimnames{dnames}}) where {dnames} = dnames
ArrayInterface.dimnames(::StaticDimnames{dnames}) where {dnames} = static(dnames)

struct DynamicDimnames{N}
    dimnames::NTuple{N,Symbol}
end
ArrayInterface.known_dimnames(::Type{DynamicDimnames{N}}) where {N} = ntuple(_-&gt; nothing, Val(N))
ArrayInterface.dimnames(x::DynamicDimnames) = getfield(x, :dimnames)
</code></pre><p>Notice that <code>DynamicDimnames</code> returns <code>nothing</code> instead of a symbol for each dimension. This indicates dimension names are present for <code>DynamicDimnames</code> but that information is nothing at compile time.</p><p>Dimension names should be appropriately propagated between nested arrays using <code>ArrayInterface.to_parent_dims</code>.  This allows types such as <code>SubArray</code> and <code>PermutedDimsArray</code> to work with named dimensions. Similarly, other methods that return information corresponding to dimensions (e.g., <code>ArrayInterfce.size</code>, <code>ArrayInterface.axes</code>) use <code>to_parent_dims</code> to appropriately propagate parent information.</p><h2 id="Axes"><a class="docs-heading-anchor" href="#Axes">Axes</a><a id="Axes-1"></a><a class="docs-heading-anchor-permalink" href="#Axes" title="Permalink"></a></h2><p>Where Julia&#39;s currently documented <a href=" https:/docs.julialang.org/en/v1/manual/interfaces/#man-interface-array">array interface</a> requires defining <code>Base.size</code>, ArrayInterface instead requires defining <a href="api/#ArrayInterface.axes"><code>ArrayInterface.axes</code></a> and <a href="api/#ArrayInterface.axes_types"><code>ArrayInterface.axes_types</code></a>. <code>ArrayInterface.axes_types(::Type{T})</code> facilitates propagation of a number of traits known at compile time (e.g., <code>known_size</code>, <code>known_offsets</code>) and <code>ArrayInterface.axes(::AbstractArray)</code> replaces <code>Base.OneTo</code> with <code>ArrayInterface.OptionallyStaticUnitRange</code> in situations where static information would otherwise be lost. <code>ArrayInterface.axes(::AbstractArray, dim)</code> utilizes <code>to_dims</code>, <a href="#dimensions">as described elsewhere</a>.</p><h3 id="Simple-Wrappers"><a class="docs-heading-anchor" href="#Simple-Wrappers">Simple Wrappers</a><a id="Simple-Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Wrappers" title="Permalink"></a></h3><p>Let&#39;s say we have a new array type doesn&#39;t affect axes then this is as simple as:</p><pre><code class="language-julia hljs">Base.axes(x::SimpleWrapper) = ArrayInterface.axes(parent(x))
Base.axes(x::SimpleWrapper, dim) = ArrayInterface.axes(parent(x), dim)
ArrayInterface.axes_types(::Type{T}) where {T&lt;:SimpleWrapper} = axes_types(parent_type(T))</code></pre><p>To reiterate, <code>ArrayInterface.axes</code> improves on <code>Base.axes</code> for few Base array types but is otherwise identical. Therefore, the first method simply ensures you don&#39;t have to define multiple parametric methods for your new type to preserve statically sized nested axes (e.g., <code>SimpleWrapper{T,N,&lt;:Transpose{T,&lt;:AbstractVector}}</code>). This is otherwise identical to standard inheritance by composition.</p><h3 id="When-to-Discard-Axis-Information"><a class="docs-heading-anchor" href="#When-to-Discard-Axis-Information">When to Discard Axis Information</a><a id="When-to-Discard-Axis-Information-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Discard-Axis-Information" title="Permalink"></a></h3><p>Occasionally the parent array&#39;s axis information can&#39;t be preserved. For example, we can&#39;t map axis information from the parent array of <code>Base.ReshapedArray</code>. In this case we can simply build axes from the new size information.</p><pre><code class="language-julia hljs">ArrayInterface.axes_types(T::Type{&lt;:ReshapedArray}) = NTuple{ndims(T),OneTo{Int}}
ArrayInterface.axes(A::ReshapedArray) = map(OneTo, size(A))</code></pre><h3 id="New-Axis-Types"><a class="docs-heading-anchor" href="#New-Axis-Types">New Axis Types</a><a id="New-Axis-Types-1"></a><a class="docs-heading-anchor-permalink" href="#New-Axis-Types" title="Permalink"></a></h3><p><code>OffsetArray</code> changes the first index for each axis. It produces axes of type <code>IdOffsetRange</code>, which contains the value of the relative offset and the parent axis.</p><pre><code class="language-julia hljs">using ArrayInterface: axes_types, parent_type, to_dims
# Note that generating a `Tuple` type piecewise like may be type unstable and should be
# tested using `Test.@inferred`. It&#39;s often necessary to use generated function
# (`@generated`) or methods defined in Static.jl.
@generated function ArrayInterface.axes_types(::Type{A}) where {A&lt;:OffsetArray}
    out = Expr(:curly, :Tuple)
    P = parent_type(A)
    for dim in 1:ndims(A)
        # offset relative to parent array
        O = relative_known_offsets(A, dim)
        if O === nothing  # offset is not known at compile time and is an `Int`
            push!(out.args, :(IdOffsetRange{Int, axes_types($P, $(static(dim)))}))
        else # offset is known, therefore it is a `StaticInt`
            push!(out.args, :(IdOffsetRange{StaticInt{$O}, axes_types($P, $(static(dim))}))
        end
    end
end
function Base.axes(A::OffsetArray)
    map(IdOffsetRange, ArrayInterface.axes(parent(A)), relative_offsets(A))
end
function Base.axes(A::OffsetArray, dim)
    d = to_dims(A, dim)
    IdOffsetRange(ArrayInterface.axes(parent(A), d), relative_offsets(A, d))
end</code></pre><p>Defining these two methods ensures that other array types that wrap <code>OffsetArray</code> and appropriately define these methods propagate offsets independent of any dependency on <code>OffsetArray</code>. It is entirely optional to define <code>ArrayInterface.size</code> for <code>OffsetArray</code> because the size can be derived from the axes. However, in this particularly case we should also define  <code>ArrayInterface.size(A::OffsetArray)  = ArrayInterface.size(parent(A))</code> because the relative offsets attached to <code>OffsetArray</code> do not change the size but may hide static sizes if using a relative offset that is defined with an <code>Int</code>.</p><h2 id="Processing-Indices-(to_indices)"><a class="docs-heading-anchor" href="#Processing-Indices-(to_indices)">Processing Indices (<code>to_indices</code>)</a><a id="Processing-Indices-(to_indices)-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-Indices-(to_indices)" title="Permalink"></a></h2><p>For most users, the only reason you should use <code>ArrayInterface.to_indices</code> over <code>Base.to_indices</code> is that it&#39;s faster and perhaps some of the more detailed benefits described in the <a href="api/#ArrayInterface.to_indices"><code>to_indices</code></a> doc string. For those interested in how this is accomplished, the following steps (beginning with the <code>to_indices(A::AbstractArray, I::Tuple)</code>) are used to accomplish this:</p><ol><li>The number of dimensions that each indexing argument in <code>I</code> corresponds to is determined using using the <a href="api/#ArrayInterface.ndims_index"><code>ndims_index</code></a> and <a href="api/#ArrayInterface.is_splat_index"><code>is_splat_index</code></a> traits.</li><li>A non-allocating reference to each axis of <code>A</code> is created (<code>lazy_axes(A) -&gt; axs</code>). These are aligned to each the index arguments using information from the first step. For example, if an index argument maps to a single dimension then it is paired with <code>axs[dim]</code>. In the case of multiple dimensions it is paired with <code>CartesianIndices(axs[dim_1], ... axs[dim_n])</code>. These pairs are further processed using <code>to_index(axis, I[n])</code>.</li><li>Tuples returned from <code>to_index</code> are flattened out so that there are no nested tuples returned from <code>to_indices</code>.</li></ol><p>Entry points:</p><ul><li><code>to_indices(::ArrayType, indices)</code> : dispatch on unique array type <code>ArrayType</code></li><li><code>to_index(axis, ::IndexType)</code> : dispatch on a unique indexing type, <code>IndexType</code>. <code>ArrayInterface.ndims_index(::Type{IndexType})</code> should also be defined in this case.</li><li><code>to_index(S::IndexStyle, axis, index)</code> : The index style <code>S</code> that corresponds to <code>axis</code>. This is </li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Monday 14 March 2022 00:53">Monday 14 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
